module.exports = function(g, r, i, a, m, e, d) {
  var t = r(d[0]),
      n = r(d[1]);
  Object.defineProperty(e, "__esModule", {
      value: !0
  }), e.default = void 0;
  var o = t(r(d[2])),
      l = t(r(d[3])),
      s = t(r(d[4])),
      u = t(r(d[5])),
      p = t(r(d[6])),
      c = t(r(d[7])),
      w = n(r(d[8])),
      f = t(r(d[9])),
      h = r(d[10]),
      v = r(d[11]),
      _ = "/Users/linyiting/Desktop/Arrow/arrow/node_modules/react-native-gesture-handler/DrawerLayout.js";

  function y(t, n) {
      var o = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
          var l = Object.getOwnPropertySymbols(t);
          n && (l = l.filter(function(n) {
              return Object.getOwnPropertyDescriptor(t, n).enumerable
          })), o.push.apply(o, l)
      }
      return o
  }

  function S(t) {
      for (var n = 1; n < arguments.length; n++) {
          var l = null != arguments[n] ? arguments[n] : {};
          n % 2 ? y(l, !0).forEach(function(n) {
              (0, o.default)(t, n, l[n])
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(l)) : y(l).forEach(function(n) {
              Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(l, n))
          })
      }
      return t
  }
  var b = .05,
      V = 'Idle',
      A = 'Dragging',
      D = 'Settling',
      C = (function(t) {
          function n(t, o) {
              var s;
              (0, l.default)(this, n), (s = (0, u.default)(this, (0, p.default)(n).call(this, t, o)))._accessibilityIsModalView = w.default.createRef(), s._pointerEventsView = w.default.createRef(), s._panGestureHandler = w.default.createRef(), s._drawerShown = !1, s._updateAnimatedEvent = function(t, n) {
                  var o = t.drawerPosition,
                      l = t.drawerWidth,
                      u = t.drawerType,
                      p = n.dragX,
                      c = n.touchX,
                      w = n.drawerTranslation,
                      f = n.containerWidth,
                      v = p,
                      _ = c;
                  'left' !== o ? (v = h.Animated.multiply(new h.Animated.Value(-1), p), _ = h.Animated.add(new h.Animated.Value(f), h.Animated.multiply(new h.Animated.Value(-1), c)), c.setValue(f)) : c.setValue(0);
                  var y = v;
                  if ('front' === u) {
                      var S = h.Animated.add(_, h.Animated.multiply(new h.Animated.Value(-1), v)).interpolate({
                          inputRange: [l - 1, l, l + 1],
                          outputRange: [0, 0, 1]
                      });
                      y = h.Animated.add(v, S)
                  }
                  s._openValue = h.Animated.add(y, w).interpolate({
                      inputRange: [0, l],
                      outputRange: [0, 1],
                      extrapolate: 'clamp'
                  }), s._onGestureEvent = h.Animated.event([{
                      nativeEvent: {
                          translationX: p,
                          x: c
                      }
                  }], {
                      useNativeDriver: t.useNativeAnimations
                  })
              }, s._handleContainerLayout = function(t) {
                  var n = t.nativeEvent;
                  s.setState({
                      containerWidth: n.layout.width
                  })
              }, s._emitStateChanged = function(t, n) {
                  s.props.onDrawerStateChanged && s.props.onDrawerStateChanged(t, n)
              }, s._openingHandlerStateChange = function(t) {
                  var n = t.nativeEvent;
                  n.oldState === v.State.ACTIVE ? s._handleRelease(n) : n.state === v.State.ACTIVE && (s._emitStateChanged(A, !1), 'on-drag' === s.props.keyboardDismissMode && h.Keyboard.dismiss(), s.props.hideStatusBar && h.StatusBar.setHidden(!0, s.props.statusBarAnimation || 'slide'))
              }, s._onTapHandlerStateChange = function(t) {
                  var n = t.nativeEvent;
                  s._drawerShown && n.oldState === v.State.ACTIVE && 'locked-open' !== s.props.drawerLockMode && s.closeDrawer()
              }, s._handleRelease = function(t) {
                  var n = s.props,
                      o = n.drawerWidth,
                      l = n.drawerPosition,
                      u = n.drawerType,
                      p = s.state.containerWidth,
                      c = t.translationX,
                      w = t.velocityX,
                      f = t.x;
                  'left' !== l && (c = -c, f = p - f, w = -w);
                  var h = f - c,
                      v = 0;
                  'front' === u && (v = h > o ? h - o : 0);
                  var _ = c + v + (s._drawerShown ? o : 0);
                  _ + b * w > o / 2 ? s._animateDrawer(_, o, w) : s._animateDrawer(_, 0, w)
              }, s._updateShowing = function(t) {
                  s._drawerShown = t, s._accessibilityIsModalView.current && s._accessibilityIsModalView.current.setNativeProps({
                      accessibilityViewIsModal: t
                  }), s._pointerEventsView.current && s._pointerEventsView.current.setNativeProps({
                      pointerEvents: t ? 'auto' : 'none'
                  });
                  var n = s.props,
                      o = n.drawerPosition,
                      l = n.minSwipeDistance,
                      u = n.edgeWidth,
                      p = 'left' === o,
                      c = (p ? 1 : -1) * (s._drawerShown ? -1 : 1),
                      w = p ? {
                          left: 0,
                          width: t ? void 0 : u
                      } : {
                          right: 0,
                          width: t ? void 0 : u
                      };
                  s._panGestureHandler.current && s._panGestureHandler.current.setNativeProps({
                      hitSlop: w,
                      activeOffsetX: c * l
                  })
              }, s._animateDrawer = function(t, n, o) {
                  if (s.state.dragX.setValue(0), s.state.touchX.setValue('left' === s.props.drawerPosition ? 0 : s.state.containerWidth), void 0 !== t) {
                      var l = t;
                      s.props.useNativeAnimations && (t < n && o > 0 ? l = Math.min(t + o / 60, n) : t > n && o < 0 && (l = Math.max(t + o / 60, n))), s.state.drawerTranslation.setValue(l)
                  }
                  var u = 0 !== n;
                  s._updateShowing(u), s._emitStateChanged(D, u), s.props.hideStatusBar && h.StatusBar.setHidden(u, s.props.statusBarAnimation || 'slide'), h.Animated.spring(s.state.drawerTranslation, {
                      velocity: o,
                      bounciness: 0,
                      toValue: n,
                      useNativeDriver: s.props.useNativeAnimations
                  }).start(function(t) {
                      t.finished && (s._emitStateChanged(V, u), u ? s.props.onDrawerOpen && s.props.onDrawerOpen() : s.props.onDrawerClose && s.props.onDrawerClose())
                  })
              }, s.openDrawer = function() {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                  s._animateDrawer(void 0, s.props.drawerWidth, t.velocity ? t.velocity : 0), s.forceUpdate()
              }, s.closeDrawer = function() {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                  s._animateDrawer(void 0, 0, t.velocity ? t.velocity : 0), s.forceUpdate()
              }, s._renderOverlay = function() {
                  (0, f.default)(s._openValue, 'should be set');
                  var t = {
                      opacity: s._openValue.interpolate({
                          inputRange: [0, 1],
                          outputRange: [0, .7],
                          extrapolate: 'clamp'
                      }),
                      backgroundColor: s.props.overlayColor
                  };
                  return w.default.createElement(v.TapGestureHandler, {
                      onHandlerStateChange: s._onTapHandlerStateChange,
                      __source: {
                          fileName: _,
                          lineNumber: 381
                      }
                  }, w.default.createElement(h.Animated.View, {
                      pointerEvents: s._drawerShown ? 'auto' : 'none',
                      ref: s._pointerEventsView,
                      style: [E.overlay, t],
                      __source: {
                          fileName: _,
                          lineNumber: 382
                      }
                  }))
              }, s._renderDrawer = function() {
                  var t, n = s.props,
                      o = n.drawerBackgroundColor,
                      l = n.drawerWidth,
                      u = n.drawerPosition,
                      p = n.drawerType,
                      c = n.drawerContainerStyle,
                      v = n.contentContainerStyle,
                      y = 'left' === u,
                      S = 'back' !== p,
                      b = 'front' !== p,
                      V = h.I18nManager.isRTL ? y : !y,
                      A = {
                          backgroundColor: o,
                          width: l
                      },
                      D = s._openValue;
                  ((0, f.default)(D, 'should be set'), b) && (t = {
                      transform: [{
                          translateX: D.interpolate({
                              inputRange: [0, 1],
                              outputRange: y ? [0, l] : [0, -l],
                              extrapolate: 'clamp'
                          })
                      }]
                  });
                  var C = 0;
                  if (S) {
                      var O = y ? -l : l;
                      C = D.interpolate({
                          inputRange: [0, 1],
                          outputRange: [O, 0],
                          extrapolate: 'clamp'
                      })
                  }
                  var P = {
                      transform: [{
                          translateX: C
                      }],
                      flexDirection: V ? 'row-reverse' : 'row'
                  };
                  return w.default.createElement(h.Animated.View, {
                      style: E.main,
                      onLayout: s._handleContainerLayout,
                      __source: {
                          fileName: _,
                          lineNumber: 445
                      }
                  }, w.default.createElement(h.Animated.View, {
                      style: ['front' === p ? E.containerOnBack : E.containerInFront, t, v],
                      __source: {
                          fileName: _,
                          lineNumber: 446
                      }
                  }, 'function' == typeof s.props.children ? s.props.children(s._openValue) : s.props.children, s._renderOverlay()), w.default.createElement(h.Animated.View, {
                      pointerEvents: "box-none",
                      ref: s._accessibilityIsModalView,
                      accessibilityViewIsModal: s._drawerShown,
                      style: [E.drawerContainer, P, c],
                      __source: {
                          fileName: _,
                          lineNumber: 459
                      }
                  }, w.default.createElement(h.View, {
                      style: A,
                      __source: {
                          fileName: _,
                          lineNumber: 464
                      }
                  }, s.props.renderNavigationView(s._openValue))))
              }, s._setPanGestureRef = function(t) {
                  s._panGestureHandler.current = t, s.props.onGestureRef && s.props.onGestureRef(t)
              };
              var c = new h.Animated.Value(0),
                  y = new h.Animated.Value(0),
                  S = new h.Animated.Value(0);
              return s.state = {
                  dragX: c,
                  touchX: y,
                  drawerTranslation: S,
                  containerWidth: 0
              }, s._updateAnimatedEvent(t, s.state), s
          }
          return (0, c.default)(n, t), (0, s.default)(n, [{
              key: "componentWillUpdate",
              value: function(t, n) {
                  this.props.drawerPosition === t.drawerPosition && this.props.drawerWidth === t.drawerWidth && this.props.drawerType === t.drawerType && this.state.containerWidth === n.containerWidth || this._updateAnimatedEvent(t, n)
              }
          }, {
              key: "render",
              value: function() {
                  var t = this.props,
                      n = t.drawerPosition,
                      o = t.drawerLockMode,
                      l = t.edgeWidth,
                      s = t.minSwipeDistance,
                      u = 'left' === n,
                      p = (u ? 1 : -1) * (this._drawerShown ? -1 : 1),
                      c = u ? {
                          left: 0,
                          width: this._drawerShown ? void 0 : l
                      } : {
                          right: 0,
                          width: this._drawerShown ? void 0 : l
                      };
                  return w.default.createElement(v.PanGestureHandler, {
                      ref: this._setPanGestureRef,
                      hitSlop: c,
                      activeOffsetX: p * s,
                      failOffsetY: [-15, 15],
                      onGestureEvent: this._onGestureEvent,
                      onHandlerStateChange: this._openingHandlerStateChange,
                      enabled: 'locked-closed' !== o && 'locked-open' !== o,
                      __source: {
                          fileName: _,
                          lineNumber: 501
                      }
                  }, this._renderDrawer())
              }
          }]), n
      })(w.Component);
  e.default = C, C.defaultProps = {
      drawerWidth: 200,
      drawerPosition: 'left',
      useNativeAnimations: !0,
      drawerType: 'front',
      edgeWidth: 20,
      minSwipeDistance: 3,
      overlayColor: 'black',
      drawerLockMode: 'unlocked'
  }, C.positions = {
      Left: 'left',
      Right: 'right'
  };
  var E = h.StyleSheet.create({
      drawerContainer: S({}, h.StyleSheet.absoluteFillObject, {
          zIndex: 1001,
          flexDirection: 'row'
      }),
      containerInFront: S({}, h.StyleSheet.absoluteFillObject, {
          zIndex: 1002
      }),
      containerOnBack: S({}, h.StyleSheet.absoluteFillObject),
      main: {
          flex: 1,
          zIndex: 0,
          overflow: 'hidden'
      },
      overlay: S({}, h.StyleSheet.absoluteFillObject, {
          zIndex: 1e3
      })
  })
}