module.exports = function(g, r, i, a, m, e, d) {
  var t = r(d[0]),
      o = r(d[1]);
  Object.defineProperty(e, "__esModule", {
      value: !0
  }), e.default = e.ProviderPropType = e.Animated = e.MAP_TYPES = void 0;
  var n = t(r(d[2])),
      l = t(r(d[3])),
      u = t(r(d[4])),
      s = t(r(d[5])),
      f = t(r(d[6])),
      p = t(r(d[7])),
      c = t(r(d[8])),
      h = t(r(d[9])),
      v = t(r(d[10])),
      y = t(r(d[11])),
      M = t(r(d[12])),
      C = t(r(d[13])),
      P = r(d[14]),
      b = t(r(d[15])),
      _ = t(r(d[16])),
      k = t(r(d[17])),
      R = t(r(d[18])),
      S = t(r(d[19])),
      w = t(r(d[20])),
      O = t(r(d[21])),
      T = t(r(d[22])),
      A = t(r(d[23])),
      N = t(r(d[24])),
      D = t(r(d[25])),
      E = t(r(d[26])),
      I = r(d[27]),
      L = o(r(d[28])),
      j = "/Users/linyiting/Desktop/Arrow/arrow/node_modules/react-native-maps/lib/components/MapView.js";

  function q(t, o) {
      var n = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
          var l = Object.getOwnPropertySymbols(t);
          o && (l = l.filter(function(o) {
              return Object.getOwnPropertyDescriptor(t, o).enumerable
          })), n.push.apply(n, l)
      }
      return n
  }

  function B(t) {
      for (var o = 1; o < arguments.length; o++) {
          var n = null != arguments[o] ? arguments[o] : {};
          o % 2 ? q(n, !0).forEach(function(o) {
              (0, y.default)(t, o, n[o])
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : q(n).forEach(function(o) {
              Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(n, o))
          })
      }
      return t
  }
  var U = {
      STANDARD: 'standard',
      SATELLITE: 'satellite',
      HYBRID: 'hybrid',
      TERRAIN: 'terrain',
      NONE: 'none',
      MUTEDSTANDARD: 'mutedStandard'
  };
  e.MAP_TYPES = U;
  var V = [U.TERRAIN, U.NONE],
      x = M.default.shape({
          center: M.default.shape({
              latitude: M.default.number.isRequired,
              longitude: M.default.number.isRequired
          }),
          pitch: M.default.number.isRequired,
          heading: M.default.number.isRequired,
          altitude: M.default.number.isRequired,
          zoom: M.default.number.isRequired
      }),
      F = P.ViewPropTypes || P.View.propTypes,
      H = B({}, F, {
          provider: M.default.oneOf(['google']),
          style: F.style,
          customMapStyle: M.default.array,
          customMapStyleString: M.default.string,
          showsUserLocation: M.default.bool,
          userLocationAnnotationTitle: M.default.string,
          showsMyLocationButton: M.default.bool,
          followsUserLocation: M.default.bool,
          showsPointsOfInterest: M.default.bool,
          showsCompass: M.default.bool,
          zoomEnabled: M.default.bool,
          zoomTapEnabled: M.default.bool,
          zoomControlEnabled: M.default.bool,
          rotateEnabled: M.default.bool,
          cacheEnabled: M.default.bool,
          loadingEnabled: M.default.bool,
          loadingBackgroundColor: P.ColorPropType,
          loadingIndicatorColor: P.ColorPropType,
          scrollEnabled: M.default.bool,
          pitchEnabled: M.default.bool,
          toolbarEnabled: M.default.bool,
          moveOnMarkerPress: M.default.bool,
          showsScale: M.default.bool,
          showsBuildings: M.default.bool,
          showsTraffic: M.default.bool,
          showsIndoors: M.default.bool,
          showsIndoorLevelPicker: M.default.bool,
          mapType: M.default.oneOf(Object.values(U)),
          region: M.default.shape({
              latitude: M.default.number.isRequired,
              longitude: M.default.number.isRequired,
              latitudeDelta: M.default.number.isRequired,
              longitudeDelta: M.default.number.isRequired
          }),
          initialRegion: M.default.shape({
              latitude: M.default.number.isRequired,
              longitude: M.default.number.isRequired,
              latitudeDelta: M.default.number.isRequired,
              longitudeDelta: M.default.number.isRequired
          }),
          camera: x,
          initialCamera: x,
          liteMode: M.default.bool,
          mapPadding: P.EdgeInsetsPropType,
          paddingAdjustmentBehavior: M.default.oneOf(['always', 'automatic', 'never']),
          maxDelta: M.default.number,
          minDelta: M.default.number,
          legalLabelInsets: P.EdgeInsetsPropType,
          onMapReady: M.default.func,
          onMapLoaded: M.default.func,
          onKmlReady: M.default.func,
          onRegionChange: M.default.func,
          onRegionChangeComplete: M.default.func,
          onPress: M.default.func,
          onDoublePress: M.default.func,
          onLongPress: M.default.func,
          onUserLocationChange: M.default.func,
          onPanDrag: M.default.func,
          onPoiClick: M.default.func,
          onMarkerPress: M.default.func,
          onMarkerSelect: M.default.func,
          onMarkerDeselect: M.default.func,
          onCalloutPress: M.default.func,
          onMarkerDragStart: M.default.func,
          onMarkerDrag: M.default.func,
          onMarkerDragEnd: M.default.func,
          minZoomLevel: M.default.number,
          maxZoomLevel: M.default.number,
          kmlSrc: M.default.string,
          compassOffset: P.PointPropType,
          onIndoorLevelActivated: M.default.func,
          onIndoorBuildingFocused: M.default.func
      }),
      z = (function(t) {
          function o(t) {
              var n;
              return (0, s.default)(this, o), (n = (0, p.default)(this, (0, c.default)(o).call(this, t))).state = {
                  isReady: 'ios' === P.Platform.OS
              }, n._onMapReady = n._onMapReady.bind((0, h.default)(n)), n._onMarkerPress = n._onMarkerPress.bind((0, h.default)(n)), n._onChange = n._onChange.bind((0, h.default)(n)), n._onLayout = n._onLayout.bind((0, h.default)(n)), n
          }
          return (0, v.default)(o, t), (0, f.default)(o, [{
              key: "getChildContext",
              value: function() {
                  return {
                      provider: this.props.provider
                  }
              }
          }, {
              key: "getSnapshotBeforeUpdate",
              value: function(t) {
                  return this.state.isReady && this.props.customMapStyle !== t.customMapStyle && this._updateStyle(this.props), this.props.region || null
              }
          }, {
              key: "componentDidUpdate",
              value: function(t, o, n) {
                  var l = this.__lastRegion,
                      u = n;
                  l && u && (l.latitude === u.latitude && l.longitude === u.longitude && l.latitudeDelta === u.latitudeDelta && l.longitudeDelta === u.longitudeDelta || this.map.setNativeProps({
                      region: u
                  }))
              }
          }, {
              key: "componentDidMount",
              value: function() {
                  this.state.isReady && this._updateStyle(this.props)
              }
          }, {
              key: "_updateStyle",
              value: function(t) {
                  var o = t.customMapStyle;
                  this.map.setNativeProps({
                      customMapStyleString: JSON.stringify(o)
                  })
              }
          }, {
              key: "_onMapReady",
              value: function() {
                  var t = this.props,
                      o = t.region,
                      n = t.initialRegion,
                      l = t.onMapReady;
                  o ? this.map.setNativeProps({
                      region: o
                  }) : n && this.map.setNativeProps({
                      initialRegion: n
                  }), this._updateStyle(this.props), this.setState({
                      isReady: !0
                  }, function() {
                      l && l()
                  })
              }
          }, {
              key: "_onLayout",
              value: function(t) {
                  var o = t.nativeEvent.layout;
                  if (o.width && o.height) {
                      if (this.state.isReady && !this.__layoutCalled) {
                          var n = this.props,
                              l = n.region,
                              u = n.initialRegion;
                          l ? (this.__layoutCalled = !0, this.map.setNativeProps({
                              region: l
                          })) : u && (this.__layoutCalled = !0, this.map.setNativeProps({
                              initialRegion: u
                          }))
                      }
                      this.props.onLayout && this.props.onLayout(t)
                  }
              }
          }, {
              key: "_onMarkerPress",
              value: function(t) {
                  this.props.onMarkerPress && this.props.onMarkerPress(t.nativeEvent)
              }
          }, {
              key: "_onChange",
              value: function(t) {
                  this.__lastRegion = t.nativeEvent.region, t.nativeEvent.continuous ? this.props.onRegionChange && this.props.onRegionChange(t.nativeEvent.region) : this.props.onRegionChangeComplete && this.props.onRegionChangeComplete(t.nativeEvent.region)
              }
          }, {
              key: "getCamera",
              value: function() {
                  return 'android' === P.Platform.OS ? P.NativeModules.AirMapModule.getCamera(this._getHandle()) : 'ios' === P.Platform.OS ? this._runCommand('getCamera', []) : Promise.reject('getCamera not supported on this platform')
              }
          }, {
              key: "setCamera",
              value: function(t) {
                  this._runCommand('setCamera', [t])
              }
          }, {
              key: "animateCamera",
              value: function(t, o) {
                  this._runCommand('animateCamera', [t, o && o.duration || 500])
              }
          }, {
              key: "animateToNavigation",
              value: function(t, o, n, l) {
                  console.warn('animateToNavigation() is deprecated, use animateCamera() instead'), this._runCommand('animateToNavigation', [t, o, n, l || 500])
              }
          }, {
              key: "animateToRegion",
              value: function(t, o) {
                  this._runCommand('animateToRegion', [t, o || 500])
              }
          }, {
              key: "animateToCoordinate",
              value: function(t, o) {
                  console.warn('animateToCoordinate() is deprecated, use animateCamera() instead'), this._runCommand('animateToCoordinate', [t, o || 500])
              }
          }, {
              key: "animateToBearing",
              value: function(t, o) {
                  console.warn('animateToBearing() is deprecated, use animateCamera() instead'), this._runCommand('animateToBearing', [t, o || 500])
              }
          }, {
              key: "animateToViewingAngle",
              value: function(t, o) {
                  console.warn('animateToViewingAngle() is deprecated, use animateCamera() instead'), this._runCommand('animateToViewingAngle', [t, o || 500])
              }
          }, {
              key: "fitToElements",
              value: function(t) {
                  this._runCommand('fitToElements', [t])
              }
          }, {
              key: "fitToSuppliedMarkers",
              value: function(t) {
                  var o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                      n = o.edgePadding,
                      l = void 0 === n ? {
                          top: 0,
                          right: 0,
                          bottom: 0,
                          left: 0
                      } : n,
                      u = o.animated,
                      s = void 0 === u || u;
                  this._runCommand('fitToSuppliedMarkers', [t, l, s])
              }
          }, {
              key: "fitToCoordinates",
              value: function() {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                      o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                      n = o.edgePadding,
                      l = void 0 === n ? {
                          top: 0,
                          right: 0,
                          bottom: 0,
                          left: 0
                      } : n,
                      u = o.animated,
                      s = void 0 === u || u;
                  this._runCommand('fitToCoordinates', [t, l, s])
              }
          }, {
              key: "getMapBoundaries",
              value: function() {
                  return u.default.async(function(t) {
                      for (;;) switch (t.prev = t.next) {
                          case 0:
                              if ('android' !== P.Platform.OS) {
                                  t.next = 6;
                                  break
                              }
                              return t.next = 3, u.default.awrap(P.NativeModules.AirMapModule.getMapBoundaries(this._getHandle()));
                          case 3:
                              return t.abrupt("return", t.sent);
                          case 6:
                              if ('ios' !== P.Platform.OS) {
                                  t.next = 10;
                                  break
                              }
                              return t.next = 9, u.default.awrap(this._runCommand('getMapBoundaries', []));
                          case 9:
                              return t.abrupt("return", t.sent);
                          case 10:
                              return t.abrupt("return", Promise.reject('getMapBoundaries not supported on this platform'));
                          case 11:
                          case "end":
                              return t.stop()
                      }
                  }, null, this)
              }
          }, {
              key: "setMapBoundaries",
              value: function(t, o) {
                  this._runCommand('setMapBoundaries', [t, o])
              }
          }, {
              key: "setIndoorActiveLevelIndex",
              value: function(t) {
                  this._runCommand('setIndoorActiveLevelIndex', [t])
              }
          }, {
              key: "takeSnapshot",
              value: function(t) {
                  var o = this;
                  if ('ios' !== P.Platform.OS || 4 !== arguments.length) {
                      var n = {
                          width: t.width || 0,
                          height: t.height || 0,
                          region: t.region || {},
                          format: t.format || 'png',
                          quality: t.quality || 1,
                          result: t.result || 'file'
                      };
                      if ('png' !== n.format && 'jpg' !== n.format) throw new Error('Invalid format specified');
                      if ('file' !== n.result && 'base64' !== n.result) throw new Error('Invalid result specified');
                      return 'android' === P.Platform.OS ? P.NativeModules.AirMapModule.takeSnapshot(this._getHandle(), n) : 'ios' === P.Platform.OS ? new Promise(function(t, l) {
                          o._runCommand('takeSnapshot', [n.width, n.height, n.region, n.format, n.quality, n.result, function(o, n) {
                              o ? l(o) : t(n)
                          }])
                      }) : Promise.reject('takeSnapshot not supported on this platform')
                  }
                  console.warn('Old takeSnapshot API has been deprecated; will be removed in the near future');
                  var l = arguments[0],
                      u = arguments[1],
                      s = arguments[2],
                      f = arguments[3];
                  this._runCommand('takeSnapshot', [l || 0, u || 0, s || {}, 'png', 1, 'legacy', f])
              }
          }, {
              key: "pointForCoordinate",
              value: function(t) {
                  return 'android' === P.Platform.OS ? P.NativeModules.AirMapModule.pointForCoordinate(this._getHandle(), t) : 'ios' === P.Platform.OS ? this._runCommand('pointForCoordinate', [t]) : Promise.reject('pointForCoordinate not supported on this platform')
              }
          }, {
              key: "coordinateForPoint",
              value: function(t) {
                  return 'android' === P.Platform.OS ? P.NativeModules.AirMapModule.coordinateForPoint(this._getHandle(), t) : 'ios' === P.Platform.OS ? this._runCommand('coordinateForPoint', [t]) : Promise.reject('coordinateForPoint not supported on this platform')
              }
          }, {
              key: "getMarkersFrames",
              value: function() {
                  var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                  return 'ios' === P.Platform.OS ? this._runCommand('getMarkersFrames', [t]) : Promise.reject('getMarkersFrames not supported on this platform')
              }
          }, {
              key: "boundingBoxForRegion",
              value: function(t) {
                  return {
                      northEast: {
                          latitude: t.latitude + t.latitudeDelta / 2,
                          longitude: t.longitude + t.longitudeDelta / 2
                      },
                      southWest: {
                          latitude: t.latitude - t.latitudeDelta / 2,
                          longitude: t.longitude - t.longitudeDelta / 2
                      }
                  }
              }
          }, {
              key: "_uiManagerCommand",
              value: function(t) {
                  var o = P.NativeModules.UIManager,
                      n = (0, I.getAirMapName)(this.props.provider);
                  return o.getViewManagerConfig ? o.getViewManagerConfig(n).Commands[t] : o[n].Commands[t]
              }
          }, {
              key: "_mapManagerCommand",
              value: function(t) {
                  if ('UI' === (0, I.getAirMapName)(this.props.provider)) {
                      var o = P.NativeModules.UIManager;
                      return o.getViewManagerConfig ? o.getViewManagerConfig(t) : o[t]
                  }
                  return P.NativeModules[(0, I.getAirMapName)(this.props.provider) + "Manager"][t]
              }
          }, {
              key: "_getHandle",
              value: function() {
                  return (0, P.findNodeHandle)(this.map)
              }
          }, {
              key: "_runCommand",
              value: function(t, o) {
                  switch (P.Platform.OS) {
                      case 'android':
                          return P.NativeModules.UIManager.dispatchViewManagerCommand(this._getHandle(), this._uiManagerCommand(t), o);
                      case 'ios':
                          return this._mapManagerCommand(t).apply(void 0, [this._getHandle()].concat((0, l.default)(o)));
                      default:
                          return Promise.reject("Invalid platform was passed: " + P.Platform.OS)
                  }
              }
          }, {
              key: "render",
              value: function() {
                  var t, o = this;
                  if (this.state.isReady ? (t = B({
                          region: null,
                          initialRegion: null,
                          onMarkerPress: this._onMarkerPress,
                          onChange: this._onChange,
                          onMapReady: this._onMapReady,
                          onLayout: this._onLayout
                      }, this.props), 'ios' === P.Platform.OS && t.provider === L.PROVIDER_DEFAULT && V.includes(t.mapType) && (t.mapType = U.standard), t.handlePanDrag = !!t.onPanDrag) : t = {
                          style: this.props.style,
                          region: null,
                          initialRegion: null,
                          onMarkerPress: this._onMarkerPress,
                          onChange: this._onChange,
                          onMapReady: this._onMapReady,
                          onLayout: this._onLayout
                      }, 'android' === P.Platform.OS && this.props.liteMode) return C.default.createElement(K, (0, n.default)({
                      ref: function(t) {
                          o.map = t
                      }
                  }, t, {
                      __source: {
                          fileName: j,
                          lineNumber: 981
                      }
                  }));
                  var l = W(this.props.provider);
                  return C.default.createElement(l, (0, n.default)({
                      ref: function(t) {
                          o.map = t
                      }
                  }, t, {
                      __source: {
                          fileName: j,
                          lineNumber: 993
                      }
                  }))
              }
          }]), o
      })(C.default.Component);
  z.propTypes = H, z.viewConfig = {
      uiViewClassName: 'AIR<provider>Map',
      validAttributes: {
          region: !0
      }
  }, z.childContextTypes = I.contextTypes, z.MAP_TYPES = U;
  var Y = function(t) {
          return (0, P.requireNativeComponent)(t, z, {
              nativeOnly: {
                  onChange: !0,
                  onMapReady: !0,
                  onKmlReady: !0,
                  handlePanDrag: !0
              }
          })
      },
      G = {
          default: Y('AIRMap')
      };
  'android' === P.Platform.OS ? G.google = G.default : G.google = I.googleMapIsInstalled ? Y('AIRGoogleMap') : (0, I.createNotSupportedComponent)('react-native-maps: AirGoogleMaps dir must be added to your xCode project to support GoogleMaps on iOS.');
  var K, W = function(t) {
      return G[t || 'default']
  };
  K = P.NativeModules.UIManager.getViewManagerConfig ? P.NativeModules.UIManager.getViewManagerConfig('AIRMapLite') && (0, P.requireNativeComponent)('AIRMapLite', z, {
      nativeOnly: {
          onChange: !0,
          onMapReady: !0,
          handlePanDrag: !0
      }
  }) : P.NativeModules.UIManager.AIRMapLite && (0, P.requireNativeComponent)('AIRMapLite', z, {
      nativeOnly: {
          onChange: !0,
          onMapReady: !0,
          handlePanDrag: !0
      }
  });
  var Z = P.Animated.createAnimatedComponent(z);
  e.Animated = Z;
  var J = M.default.oneOf(Object.values(L));
  e.ProviderPropType = J, z.Marker = b.default, z.Polyline = _.default, z.Polygon = k.default, z.Circle = R.default, z.UrlTile = T.default, z.MapWMSTile = A.default, z.LocalTile = N.default, z.Heatmap = D.default, z.Overlay = O.default, z.Callout = S.default, z.CalloutSubview = w.default, (0, n.default)(z, L), z.ProviderPropType = J, z.Animated = Z, z.AnimatedRegion = E.default;
  var Q = z;
  e.default = Q
}