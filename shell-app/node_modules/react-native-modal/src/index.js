module.exports = function(g, r, i, a, m, e, d) {
  var t = r(d[0]),
      n = r(d[1]);
  Object.defineProperty(e, "__esModule", {
      value: !0
  }), e.ReactNativeModal = e.default = void 0;
  var o = t(r(d[2])),
      s = t(r(d[3])),
      l = t(r(d[4])),
      p = t(r(d[5])),
      c = t(r(d[6])),
      u = t(r(d[7])),
      f = t(r(d[8])),
      h = t(r(d[9])),
      b = n(r(d[10])),
      w = r(d[11]),
      v = t(r(d[12])),
      S = n(r(d[13])),
      y = r(d[14]),
      O = t(r(d[15])),
      D = "/Users/linyiting/Desktop/Arrow/arrow/node_modules/react-native-modal/src/index.js";

  function k(t, n) {
      var o = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
          var s = Object.getOwnPropertySymbols(t);
          n && (s = s.filter(function(n) {
              return Object.getOwnPropertyDescriptor(t, n).enumerable
          })), o.push.apply(o, s)
      }
      return o
  }

  function T(t) {
      for (var n = 1; n < arguments.length; n++) {
          var o = null != arguments[n] ? arguments[n] : {};
          n % 2 ? k(o, !0).forEach(function(n) {
              (0, l.default)(t, n, o[n])
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(o)) : k(o).forEach(function(n) {
              Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(o, n))
          })
      }
      return t
  }(0, y.initializeAnimations)();
  var M = function(t) {
          return -(t - 1)
      },
      P = (function(t) {
          function n(t) {
              var o;
              (0, p.default)(this, n), (o = (0, c.default)(this, (0, u.default)(n).call(this, t))).state = {
                  showContent: !0,
                  isVisible: !1,
                  deviceWidth: w.Dimensions.get('window').width,
                  deviceHeight: w.Dimensions.get('window').height,
                  isSwipeable: !!o.props.swipeDirection,
                  pan: null
              }, o.isTransitioning = !1, o.inSwipeClosingState = !1, o.currentSwipingDirection = null, o.buildPanResponder = function() {
                  var t = null;
                  o.panResponder = w.PanResponder.create({
                      onMoveShouldSetPanResponder: function(n, s) {
                          if (!o.props.propagateSwipe) {
                              var l = Math.abs(s.dx) >= 4 || Math.abs(s.dy) >= 4;
                              return l && o.props.onSwipeStart && o.props.onSwipeStart(), o.currentSwipingDirection = o.getSwipingDirection(s), t = o.createAnimationEventForSwipe(), l
                          }
                      },
                      onStartShouldSetPanResponder: function() {
                          return !(o.props.scrollTo && o.props.scrollOffset > 0) && (o.props.onSwipeStart && o.props.onSwipeStart(), o.currentSwipingDirection = null, !0)
                      },
                      onPanResponderMove: function(n, s) {
                          if (!o.currentSwipingDirection) {
                              if (0 === s.dx && 0 === s.dy) return;
                              o.currentSwipingDirection = o.getSwipingDirection(s), t = o.createAnimationEventForSwipe()
                          }
                          if (o.isSwipeDirectionAllowed(s)) {
                              var l = 1 - o.calcDistancePercentage(s);
                              o.backdropRef && o.backdropRef.transitionTo({
                                  opacity: o.props.backdropOpacity * l
                              }), t(n, s), o.props.onSwipeMove && o.props.onSwipeMove(l)
                          } else if (o.props.scrollTo)
                              if (o.props.scrollHorizontal) {
                                  var p = -s.dx;
                                  p > o.props.scrollOffsetMax && (p -= (p - o.props.scrollOffsetMax) / 2), o.props.scrollTo({
                                      x: p,
                                      animated: !1
                                  })
                              } else {
                                  var c = -s.dy;
                                  c > o.props.scrollOffsetMax && (c -= (c - o.props.scrollOffsetMax) / 2), o.props.scrollTo({
                                      y: c,
                                      animated: !1
                                  })
                              }
                      },
                      onPanResponderRelease: function(t, n) {
                          if (o.getAccDistancePerDirection(n) > o.props.swipeThreshold && o.isSwipeDirectionAllowed(n)) {
                              if (o.props.onSwipeComplete) return o.inSwipeClosingState = !0, void o.props.onSwipeComplete({
                                  swipingDirection: o.getSwipingDirection(n)
                              });
                              if (o.props.onSwipe) return o.inSwipeClosingState = !0, void o.props.onSwipe()
                          }
                          o.props.onSwipeCancel && o.props.onSwipeCancel(), o.backdropRef && o.backdropRef.transitionTo({
                              opacity: o.props.backdropOpacity
                          }), w.Animated.spring(o.state.pan, {
                              toValue: {
                                  x: 0,
                                  y: 0
                              },
                              bounciness: 0
                          }).start(), o.props.scrollOffset > o.props.scrollOffsetMax && o.props.scrollTo({
                              y: o.props.scrollOffsetMax,
                              animated: !0
                          })
                      }
                  })
              }, o.getAccDistancePerDirection = function(t) {
                  switch (o.currentSwipingDirection) {
                      case 'up':
                          return -t.dy;
                      case 'down':
                          return t.dy;
                      case 'right':
                          return t.dx;
                      case 'left':
                          return -t.dx;
                      default:
                          return 0
                  }
              }, o.getSwipingDirection = function(t) {
                  return Math.abs(t.dx) > Math.abs(t.dy) ? t.dx > 0 ? 'right' : 'left' : t.dy > 0 ? 'down' : 'up'
              }, o.calcDistancePercentage = function(t) {
                  switch (o.currentSwipingDirection) {
                      case 'down':
                          return (t.moveY - t.y0) / ((o.props.deviceHeight || o.state.deviceHeight) - t.y0);
                      case 'up':
                          return M(t.moveY / t.y0);
                      case 'left':
                          return M(t.moveX / t.x0);
                      case 'right':
                          return (t.moveX - t.x0) / ((o.props.deviceWidth || o.state.deviceWidth) - t.x0);
                      default:
                          return 0
                  }
              }, o.createAnimationEventForSwipe = function() {
                  return 'right' === o.currentSwipingDirection || 'left' === o.currentSwipingDirection ? w.Animated.event([null, {
                      dx: o.state.pan.x
                  }]) : w.Animated.event([null, {
                      dy: o.state.pan.y
                  }])
              }, o.isDirectionIncluded = function(t) {
                  return Array.isArray(o.props.swipeDirection) ? o.props.swipeDirection.includes(t) : o.props.swipeDirection === t
              }, o.isSwipeDirectionAllowed = function(t) {
                  var n = t.dy,
                      s = t.dx,
                      l = n > 0,
                      p = n < 0,
                      c = s < 0,
                      u = s > 0;
                  return !('up' !== o.currentSwipingDirection || !o.isDirectionIncluded('up') || !p) || (!('down' !== o.currentSwipingDirection || !o.isDirectionIncluded('down') || !l) || (!('right' !== o.currentSwipingDirection || !o.isDirectionIncluded('right') || !u) || !('left' !== o.currentSwipingDirection || !o.isDirectionIncluded('left') || !c)))
              }, o.handleDimensionsUpdate = function(t) {
                  if (!o.props.deviceHeight && !o.props.deviceWidth) {
                      var n = w.Dimensions.get('window').width,
                          s = w.Dimensions.get('window').height;
                      n === o.state.deviceWidth && s === o.state.deviceHeight || o.setState({
                          deviceWidth: n,
                          deviceHeight: s
                      })
                  }
              }, o.open = function() {
                  o.isTransitioning || (o.isTransitioning = !0, o.backdropRef && o.backdropRef.transitionTo({
                      opacity: o.props.backdropOpacity
                  }, o.props.backdropTransitionInTiming), o.state.isSwipeable && o.state.pan.setValue({
                      x: 0,
                      y: 0
                  }), o.contentRef && (o.props.onModalWillShow && o.props.onModalWillShow(), o.contentRef[o.animationIn](o.props.animationInTiming).then(function() {
                      o.isTransitioning = !1, o.props.isVisible ? o.props.onModalShow() : o.close()
                  })))
              }, o.close = function() {
                  if (!o.isTransitioning) {
                      o.isTransitioning = !0, o.backdropRef && o.backdropRef.transitionTo({
                          opacity: 0
                      }, o.props.backdropTransitionOutTiming);
                      var t = o.animationOut;
                      o.inSwipeClosingState && (o.inSwipeClosingState = !1, 'up' === o.currentSwipingDirection ? t = 'slideOutUp' : 'down' === o.currentSwipingDirection ? t = 'slideOutDown' : 'right' === o.currentSwipingDirection ? t = 'slideOutRight' : 'left' === o.currentSwipingDirection && (t = 'slideOutLeft')), o.contentRef && (o.props.onModalWillHide && o.props.onModalWillHide(), o.contentRef[t](o.props.animationOutTiming).then(function() {
                          o.isTransitioning = !1, o.props.isVisible ? o.open() : o.setState({
                              showContent: !1
                          }, function() {
                              o.setState({
                                  isVisible: !1
                              }, function() {
                                  o.props.onModalHide()
                              })
                          })
                      }))
                  }
              };
              var s = (0, y.buildAnimations)(t),
                  l = s.animationIn,
                  f = s.animationOut;
              return o.animationIn = l, o.animationOut = f, o.state.isSwipeable && (o.state = T({}, o.state, {
                  pan: new w.Animated.ValueXY
              }), o.buildPanResponder()), o.props.isVisible && (o.state = T({}, o.state, {
                  isVisible: !0,
                  showContent: !0
              })), o
          }
          return (0, h.default)(n, t), (0, f.default)(n, null, [{
              key: "getDerivedStateFromProps",
              value: function(t, n) {
                  return !n.isVisible && t.isVisible ? {
                      isVisible: !0,
                      showContent: !0
                  } : null
              }
          }]), (0, f.default)(n, [{
              key: "componentDidUpdate",
              value: function(t) {
                  if (this.props.animationIn !== t.animationIn || this.props.animationOut !== t.animationOut) {
                      var n = (0, y.buildAnimations)(t),
                          o = n.animationIn,
                          s = n.animationOut;
                      this.animationIn = o, this.animationOut = s
                  }
                  this.props.backdropOpacity !== t.backdropOpacity && this.backdropRef && this.backdropRef.transitionTo({
                      opacity: t.backdropOpacity
                  }, this.props.backdropTransitionInTiming)
              }
          }, {
              key: "componentDidMount",
              value: function() {
                  this.props.onSwipe && console.warn('`<Modal onSwipe="..." />` is deprecated. Use `<Modal onSwipeComplete="..." />` instead.'), this.state.isVisible && this.open(), w.DeviceEventEmitter.addListener('didUpdateDimensions', this.handleDimensionsUpdate)
              }
          }, {
              key: "componentWillUnmount",
              value: function() {
                  w.DeviceEventEmitter.removeListener('didUpdateDimensions', this.handleDimensionsUpdate)
              }
          }, {
              key: "componentDidUpdate",
              value: function(t, n) {
                  this.props.isVisible && !t.isVisible ? this.open() : !this.props.isVisible && t.isVisible && this.close()
              }
          }, {
              key: "render",
              value: function() {
                  var t = this,
                      n = this.props,
                      l = (n.animationIn, n.animationInTiming, n.animationOut, n.animationOutTiming, n.avoidKeyboard),
                      p = n.coverScreen,
                      c = n.hasBackdrop,
                      u = n.backdropColor,
                      f = (n.backdropOpacity, n.backdropTransitionInTiming, n.backdropTransitionOutTiming, n.customBackdrop),
                      h = n.children,
                      v = n.deviceHeight,
                      y = n.deviceWidth,
                      k = (n.isVisible, n.onModalShow, n.onBackdropPress),
                      M = n.onBackButtonPress,
                      P = n.useNativeDriver,
                      R = (n.propagateSwipe, n.style),
                      x = (0, s.default)(n, ["animationIn", "animationInTiming", "animationOut", "animationOutTiming", "avoidKeyboard", "coverScreen", "hasBackdrop", "backdropColor", "backdropOpacity", "backdropTransitionInTiming", "backdropTransitionOutTiming", "customBackdrop", "children", "deviceHeight", "deviceWidth", "isVisible", "onModalShow", "onBackdropPress", "onBackButtonPress", "useNativeDriver", "propagateSwipe", "style"]),
                      C = y || this.state.deviceWidth,
                      I = v || this.state.deviceHeight,
                      V = [{
                          margin: .05 * C,
                          transform: [{
                              translateY: 0
                          }]
                      }, O.default.content, R],
                      W = {},
                      N = {};
                  this.state.isSwipeable && (W = T({}, this.panResponder.panHandlers), N = P ? {
                      transform: this.state.pan.getTranslateTransform()
                  } : this.state.pan.getLayout());
                  var A = this.props.hideModalContentWhileAnimating && this.props.useNativeDriver && !this.state.showContent ? b.default.createElement(S.View, {
                          __source: {
                              fileName: D,
                              lineNumber: 588
                          }
                      }) : h,
                      H = b.default.createElement(S.View, (0, o.default)({}, W, {
                          ref: function(n) {
                              return t.contentRef = n
                          },
                          style: [N, V],
                          pointerEvents: "box-none",
                          useNativeDriver: P
                      }, x, {
                          __source: {
                              fileName: D,
                              lineNumber: 593
                          }
                      }), A),
                      B = b.default.isValidElement(f),
                      E = b.default.createElement(S.View, {
                          ref: function(n) {
                              return t.backdropRef = n
                          },
                          useNativeDriver: P,
                          style: [O.default.backdrop, {
                              width: C,
                              height: I
                          }, {
                              backgroundColor: this.state.showContent && !B ? u : 'transparent'
                          }],
                          __source: {
                              fileName: D,
                              lineNumber: 608
                          }
                      }, B && f),
                      _ = null;
                  return _ = B ? E : b.default.createElement(w.TouchableWithoutFeedback, {
                      onPress: k,
                      __source: {
                          fileName: D,
                          lineNumber: 636
                      }
                  }, E), !p && this.state.isVisible ? b.default.createElement(w.View, {
                      pointerEvents: "box-none",
                      style: [O.default.backdrop, {
                          zIndex: 2,
                          opacity: 1,
                          backgroundColor: 'transparent'
                      }],
                      __source: {
                          fileName: D,
                          lineNumber: 644
                      }
                  }, c && _, H) : b.default.createElement(w.Modal, (0, o.default)({
                      transparent: !0,
                      animationType: 'none',
                      visible: this.state.isVisible,
                      onRequestClose: M
                  }, x, {
                      __source: {
                          fileName: D,
                          lineNumber: 658
                      }
                  }), c && _, l && b.default.createElement(w.KeyboardAvoidingView, {
                      behavior: 'ios' === w.Platform.OS ? 'padding' : null,
                      pointerEvents: "box-none",
                      style: V.concat([{
                          margin: 0
                      }]),
                      __source: {
                          fileName: D,
                          lineNumber: 668
                      }
                  }, H), !l && H)
              }
          }]), n
      })(b.Component);
  e.ReactNativeModal = P, P.propTypes = {
      animationIn: v.default.oneOfType([v.default.string, v.default.object]),
      animationInTiming: v.default.number,
      animationOut: v.default.oneOfType([v.default.string, v.default.object]),
      animationOutTiming: v.default.number,
      avoidKeyboard: v.default.bool,
      coverScreen: v.default.bool,
      hasBackdrop: v.default.bool,
      backdropColor: v.default.string,
      backdropOpacity: v.default.number,
      backdropTransitionInTiming: v.default.number,
      backdropTransitionOutTiming: v.default.number,
      customBackdrop: v.default.node,
      children: v.default.node.isRequired,
      deviceHeight: v.default.number,
      deviceWidth: v.default.number,
      isVisible: v.default.bool.isRequired,
      hideModalContentWhileAnimating: v.default.bool,
      propagateSwipe: v.default.bool,
      onModalShow: v.default.func,
      onModalWillShow: v.default.func,
      onModalHide: v.default.func,
      onModalWillHide: v.default.func,
      onBackButtonPress: v.default.func,
      onBackdropPress: v.default.func,
      onSwipeStart: v.default.func,
      onSwipeMove: v.default.func,
      onSwipeComplete: v.default.func,
      onSwipeCancel: v.default.func,
      swipeThreshold: v.default.number,
      swipeDirection: v.default.oneOfType([v.default.arrayOf(v.default.oneOf(['up', 'down', 'left', 'right'])), v.default.oneOf(['up', 'down', 'left', 'right'])]),
      useNativeDriver: v.default.bool,
      style: v.default.any,
      scrollTo: v.default.func,
      scrollOffset: v.default.number,
      scrollOffsetMax: v.default.number,
      scrollHorizontal: v.default.bool,
      supportedOrientations: v.default.arrayOf(v.default.oneOf(['portrait', 'portrait-upside-down', 'landscape', 'landscape-left', 'landscape-right']))
  }, P.defaultProps = {
      animationIn: 'slideInUp',
      animationInTiming: 300,
      animationOut: 'slideOutDown',
      animationOutTiming: 300,
      avoidKeyboard: !1,
      coverScreen: !0,
      hasBackdrop: !0,
      backdropColor: 'black',
      backdropOpacity: .7,
      backdropTransitionInTiming: 300,
      backdropTransitionOutTiming: 300,
      customBackdrop: null,
      onModalShow: function() {
          return null
      },
      onModalWillShow: function() {
          return null
      },
      deviceHeight: null,
      deviceWidth: null,
      onModalHide: function() {
          return null
      },
      onModalWillHide: function() {
          return null
      },
      isVisible: !1,
      hideModalContentWhileAnimating: !1,
      propagateSwipe: v.default.false,
      onBackdropPress: function() {
          return null
      },
      onBackButtonPress: function() {
          return null
      },
      swipeThreshold: 100,
      useNativeDriver: !1,
      scrollTo: null,
      scrollOffset: 0,
      scrollOffsetMax: 0,
      scrollHorizontal: !1,
      supportedOrientations: ['portrait', 'landscape']
  };
  var R = P;
  e.default = R
}