module.exports = function(g, r, i, a, m, e, d) {
  'use strict';
  var t = r(d[0]),
      n = r(d[1]),
      o = r(d[2]),
      l = r(d[3]),
      s = r(d[4]),
      c = r(d[5]),
      p = r(d[6]),
      u = r(d[7]),
      h = "/Users/linyiting/Desktop/Arrow/arrow/node_modules/react-native/Libraries/Components/ScrollView/ScrollView.js";

  function f(t, n) {
      var o = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
          var l = Object.getOwnPropertySymbols(t);
          n && (l = l.filter(function(n) {
              return Object.getOwnPropertyDescriptor(t, n).enumerable
          })), o.push.apply(o, l)
      }
      return o
  }

  function y(t) {
      for (var n = 1; n < arguments.length; n++) {
          var o = null != arguments[n] ? arguments[n] : {};
          n % 2 ? f(o, !0).forEach(function(n) {
              u(t, n, o[n])
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(o)) : f(o).forEach(function(n) {
              Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(o, n))
          })
      }
      return t
  }
  var R, _, v, S = r(d[8]),
      w = (r(d[9]), r(d[10])),
      H = r(d[11]),
      V = r(d[12]),
      k = r(d[13]),
      A = r(d[14]),
      E = r(d[15]),
      b = (r(d[16]), r(d[17])),
      T = (r(d[18]), r(d[19])),
      C = r(d[20]),
      x = r(d[21]),
      M = r(d[22]);

  function O(t) {
      var n = y({}, V.Mixin);
      for (var o in n) 'function' == typeof n[o] && (n[o] = n[o].bind(t));
      return n
  }
  R = x('RCTScrollView'), v = x('AndroidHorizontalScrollView'), _ = x('AndroidHorizontalScrollContentView');
  var I = (function(u) {
          function f() {
              var t, o;
              n(this, f);
              for (var p = arguments.length, u = new Array(p), h = 0; h < p; h++) u[h] = arguments[h];
              for (var R in (o = l(this, (t = s(f)).call.apply(t, [this].concat(u))))._scrollResponder = O(c(o)), o._scrollAnimatedValue = new S.Value(0), o._scrollAnimatedValueAttachment = null, o._stickyHeaderRefs = new Map, o._headerLayoutYs = new Map, o.state = y({
                      layoutHeight: null
                  }, V.Mixin.scrollResponderMixinGetInitialState()), o._handleScroll = function(t) {
                      'on-drag' === o.props.keyboardDismissMode && o.state.isTouching && b(), o._scrollResponder.scrollResponderHandleScroll(t)
                  }, o._handleLayout = function(t) {
                      o.props.invertStickyHeaders && o.setState({
                          layoutHeight: t.nativeEvent.layout.height
                      }), o.props.onLayout && o.props.onLayout(t)
                  }, o._handleContentOnLayout = function(t) {
                      var n = t.nativeEvent.layout,
                          l = n.width,
                          s = n.height;
                      o.props.onContentSizeChange && o.props.onContentSizeChange(l, s)
                  }, o._scrollViewRef = null, o._setScrollViewRef = function(t) {
                      o._scrollViewRef = t
                  }, o._innerViewRef = null, o._setInnerViewRef = function(t) {
                      o._innerViewRef = t
                  }, V.Mixin) 'function' == typeof V.Mixin[R] && R.startsWith('scrollResponder') && (c(o)[R] = V.Mixin[R].bind(c(o)));
              return Object.keys(V.Mixin).filter(function(t) {
                  return 'function' != typeof V.Mixin[t]
              }).forEach(function(t) {
                  c(o)[t] = V.Mixin[t]
              }), o
          }
          return p(f, u), o(f, [{
              key: "UNSAFE_componentWillMount",
              value: function() {
                  this._scrollResponder.UNSAFE_componentWillMount(), this._scrollAnimatedValue = new S.Value(this.props.contentOffset ? this.props.contentOffset.y : 0), this._scrollAnimatedValue.setOffset(this.props.contentInset ? this.props.contentInset.top : 0), this._stickyHeaderRefs = new Map, this._headerLayoutYs = new Map
              }
          }, {
              key: "UNSAFE_componentWillReceiveProps",
              value: function(t) {
                  var n = this.props.contentInset ? this.props.contentInset.top : 0,
                      o = t.contentInset ? t.contentInset.top : 0;
                  n !== o && this._scrollAnimatedValue.setOffset(o || 0)
              }
          }, {
              key: "componentDidMount",
              value: function() {
                  this._updateAnimatedNodeAttachment()
              }
          }, {
              key: "componentDidUpdate",
              value: function() {
                  this._updateAnimatedNodeAttachment()
              }
          }, {
              key: "componentWillUnmount",
              value: function() {
                  this._scrollResponder.componentWillUnmount(), this._scrollAnimatedValueAttachment && this._scrollAnimatedValueAttachment.detach()
              }
          }, {
              key: "setNativeProps",
              value: function(t) {
                  this._scrollViewRef && this._scrollViewRef.setNativeProps(t)
              }
          }, {
              key: "getScrollResponder",
              value: function() {
                  return this
              }
          }, {
              key: "getScrollableNode",
              value: function() {
                  return H.findNodeHandle(this._scrollViewRef)
              }
          }, {
              key: "getInnerViewNode",
              value: function() {
                  return H.findNodeHandle(this._innerViewRef)
              }
          }, {
              key: "scrollTo",
              value: function(t, n, o) {
                  if ('number' == typeof t) console.warn("`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, animated: true})` instead.");
                  else {
                      var l = t || {};
                      n = l.x, t = l.y, o = l.animated
                  }
                  this._scrollResponder.scrollResponderScrollTo({
                      x: n || 0,
                      y: t || 0,
                      animated: !1 !== o
                  })
              }
          }, {
              key: "scrollToEnd",
              value: function(t) {
                  var n = !1 !== (t && t.animated);
                  this._scrollResponder.scrollResponderScrollToEnd({
                      animated: n
                  })
              }
          }, {
              key: "scrollWithoutAnimationTo",
              value: function() {
                  var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                      n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                  console.warn('`scrollWithoutAnimationTo` is deprecated. Use `scrollTo` instead'), this.scrollTo({
                      x: n,
                      y: t,
                      animated: !1
                  })
              }
          }, {
              key: "flashScrollIndicators",
              value: function() {
                  this._scrollResponder.scrollResponderFlashScrollIndicators()
              }
          }, {
              key: "_getKeyForIndex",
              value: function(t, n) {
                  var o = n[t];
                  return o && o.key
              }
          }, {
              key: "_updateAnimatedNodeAttachment",
              value: function() {
                  this._scrollAnimatedValueAttachment && this._scrollAnimatedValueAttachment.detach(), this.props.stickyHeaderIndices && this.props.stickyHeaderIndices.length > 0 && (this._scrollAnimatedValueAttachment = S.attachNativeEvent(this._scrollViewRef, 'onScroll', [{
                      nativeEvent: {
                          contentOffset: {
                              y: this._scrollAnimatedValue
                          }
                      }
                  }]))
              }
          }, {
              key: "_setStickyHeaderRef",
              value: function(t, n) {
                  n ? this._stickyHeaderRefs.set(t, n) : this._stickyHeaderRefs.delete(t)
              }
          }, {
              key: "_onStickyHeaderLayout",
              value: function(t, n, o) {
                  var l = this.props.stickyHeaderIndices;
                  if (l) {
                      var s = w.Children.toArray(this.props.children);
                      if (o === this._getKeyForIndex(t, s)) {
                          var c = n.nativeEvent.layout.y;
                          this._headerLayoutYs.set(o, c);
                          var p = l[l.indexOf(t) - 1];
                          if (null != p) {
                              var u = this._stickyHeaderRefs.get(this._getKeyForIndex(p, s));
                              u && u.setNextHeaderY(c)
                          }
                      }
                  }
              }
          }, {
              key: "render",
              value: function() {
                  var n, o, l = this;
                  this.props.horizontal ? (n = v, o = _) : (n = R, o = E), T(void 0 !== n, 'ScrollViewClass must not be undefined'), T(void 0 !== o, 'ScrollContentContainerViewClass must not be undefined');
                  var s = [this.props.horizontal && N.contentContainerHorizontal, this.props.contentContainerStyle],
                      c = {};
                  this.props.onContentSizeChange && (c = {
                      onLayout: this._handleContentOnLayout
                  });
                  var p = this.props.stickyHeaderIndices,
                      u = this.props.children;
                  if (null != p && p.length > 0) {
                      var f = w.Children.toArray(this.props.children);
                      u = f.map(function(t, n) {
                          var o = t ? p.indexOf(n) : -1;
                          if (o > -1) {
                              var s = t.key,
                                  c = p[o + 1];
                              return w.createElement(k, {
                                  key: s,
                                  ref: function(t) {
                                      return l._setStickyHeaderRef(s, t)
                                  },
                                  nextHeaderLayoutY: l._headerLayoutYs.get(l._getKeyForIndex(c, f)),
                                  onLayout: function(t) {
                                      return l._onStickyHeaderLayout(n, t, s)
                                  },
                                  scrollAnimatedValue: l._scrollAnimatedValue,
                                  inverted: l.props.invertStickyHeaders,
                                  scrollViewHeight: l.state.layoutHeight,
                                  __source: {
                                      fileName: h,
                                      lineNumber: 953
                                  }
                              }, t)
                          }
                          return t
                      })
                  }
                  var S = p && p.length > 0,
                      H = w.createElement(o, t({}, c, {
                          ref: this._setInnerViewRef,
                          style: s,
                          removeClippedSubviews: !S && this.props.removeClippedSubviews,
                          collapsable: !1,
                          __source: {
                              fileName: h,
                              lineNumber: 976
                          }
                      }), u),
                      V = void 0 !== this.props.alwaysBounceHorizontal ? this.props.alwaysBounceHorizontal : this.props.horizontal,
                      A = void 0 !== this.props.alwaysBounceVertical ? this.props.alwaysBounceVertical : !this.props.horizontal,
                      b = !!this.props.DEPRECATED_sendUpdatedChildFrames,
                      x = this.props.horizontal ? N.baseHorizontal : N.baseVertical,
                      O = y({}, this.props, {
                          alwaysBounceHorizontal: V,
                          alwaysBounceVertical: A,
                          style: [x, this.props.style],
                          onContentSizeChange: null,
                          onLayout: this._handleLayout,
                          onMomentumScrollBegin: this._scrollResponder.scrollResponderHandleMomentumScrollBegin,
                          onMomentumScrollEnd: this._scrollResponder.scrollResponderHandleMomentumScrollEnd,
                          onResponderGrant: this._scrollResponder.scrollResponderHandleResponderGrant,
                          onResponderReject: this._scrollResponder.scrollResponderHandleResponderReject,
                          onResponderRelease: this._scrollResponder.scrollResponderHandleResponderRelease,
                          onResponderTerminate: this._scrollResponder.scrollResponderHandleTerminate,
                          onResponderTerminationRequest: this._scrollResponder.scrollResponderHandleTerminationRequest,
                          onScrollBeginDrag: this._scrollResponder.scrollResponderHandleScrollBeginDrag,
                          onScrollEndDrag: this._scrollResponder.scrollResponderHandleScrollEndDrag,
                          onScrollShouldSetResponder: this._scrollResponder.scrollResponderHandleScrollShouldSetResponder,
                          onStartShouldSetResponder: this._scrollResponder.scrollResponderHandleStartShouldSetResponder,
                          onStartShouldSetResponderCapture: this._scrollResponder.scrollResponderHandleStartShouldSetResponderCapture,
                          onTouchEnd: this._scrollResponder.scrollResponderHandleTouchEnd,
                          onTouchMove: this._scrollResponder.scrollResponderHandleTouchMove,
                          onTouchStart: this._scrollResponder.scrollResponderHandleTouchStart,
                          onTouchCancel: this._scrollResponder.scrollResponderHandleTouchCancel,
                          onScroll: this._handleScroll,
                          scrollBarThumbImage: M(this.props.scrollBarThumbImage),
                          scrollEventThrottle: S ? 1 : this.props.scrollEventThrottle,
                          sendMomentumEvents: !(!this.props.onMomentumScrollBegin && !this.props.onMomentumScrollEnd),
                          DEPRECATED_sendUpdatedChildFrames: b,
                          snapToStart: !1 !== this.props.snapToStart,
                          snapToEnd: !1 !== this.props.snapToEnd,
                          pagingEnabled: this.props.pagingEnabled || null != this.props.snapToInterval || null != this.props.snapToOffsets
                      }),
                      I = this.props.decelerationRate;
                  null != I && (O.decelerationRate = C(I));
                  var D = this.props.refreshControl;
                  return D ? w.cloneElement(D, {
                      style: O.style
                  }, w.createElement(n, t({}, O, {
                      style: x,
                      ref: this._setScrollViewRef,
                      __source: {
                          fileName: h,
                          lineNumber: 1103
                      }
                  }), H)) : w.createElement(n, t({}, O, {
                      ref: this._setScrollViewRef,
                      __source: {
                          fileName: h,
                          lineNumber: 1115
                      }
                  }), H)
              }
          }]), f
      })(w.Component),
      N = A.create({
          baseVertical: {
              flexGrow: 1,
              flexShrink: 1,
              flexDirection: 'column',
              overflow: 'scroll'
          },
          baseHorizontal: {
              flexGrow: 1,
              flexShrink: 1,
              flexDirection: 'row',
              overflow: 'scroll'
          },
          contentContainerHorizontal: {
              flexDirection: 'row'
          }
      });
  m.exports = I
}