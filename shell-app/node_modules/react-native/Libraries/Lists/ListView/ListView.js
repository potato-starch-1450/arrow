module.exports = function(g, r, i, a, m, e, d) {
  'use strict';
  var t = r(d[0]),
      o = r(d[1]),
      n = "/Users/linyiting/Desktop/Arrow/arrow/node_modules/react-native/Libraries/Lists/ListView/ListView.js",
      s = (r(d[2]), r(d[3])),
      l = (r(d[4]), r(d[5])),
      h = r(d[6]),
      c = r(d[7]).ScrollViewManager,
      p = r(d[8]),
      u = r(d[9]),
      _ = r(d[10]),
      R = r(d[11]),
      f = r(d[12]),
      w = r(d[13]),
      S = r(d[14]),
      C = r(d[15]),
      v = w({
          displayName: 'ListView',
          _rafIds: [],
          _childFrames: [],
          _sentEndForContentLength: null,
          _scrollComponent: null,
          _prevRenderedRowsCount: 0,
          _visibleRows: {},
          scrollProperties: {},
          mixins: [u.Mixin],
          statics: {
              DataSource: s
          },
          getMetrics: function() {
              return {
                  contentLength: this.scrollProperties.contentLength,
                  totalRows: this.props.enableEmptySections ? this.props.dataSource.getRowAndSectionCount() : this.props.dataSource.getRowCount(),
                  renderedRows: this.state.curRenderedRowsCount,
                  visibleRows: Object.keys(this._visibleRows).length
              }
          },
          getScrollResponder: function() {
              if (this._scrollComponent && this._scrollComponent.getScrollResponder) return this._scrollComponent.getScrollResponder()
          },
          getScrollableNode: function() {
              return this._scrollComponent && this._scrollComponent.getScrollableNode ? this._scrollComponent.getScrollableNode() : h.findNodeHandle(this._scrollComponent)
          },
          scrollTo: function() {
              var t;
              this._scrollComponent && this._scrollComponent.scrollTo && (t = this._scrollComponent).scrollTo.apply(t, arguments)
          },
          scrollToEnd: function(t) {
              this._scrollComponent && (this._scrollComponent.scrollToEnd ? this._scrollComponent.scrollToEnd(t) : console.warn("The scroll component used by the ListView does not support scrollToEnd. Check the renderScrollComponent prop of your ListView."))
          },
          flashScrollIndicators: function() {
              this._scrollComponent && this._scrollComponent.flashScrollIndicators && this._scrollComponent.flashScrollIndicators()
          },
          setNativeProps: function(t) {
              this._scrollComponent && this._scrollComponent.setNativeProps(t)
          },
          getDefaultProps: function() {
              return {
                  initialListSize: 10,
                  pageSize: 1,
                  renderScrollComponent: function(t) {
                      return l.createElement(p, o({}, t, {
                          __source: {
                              fileName: n,
                              lineNumber: 324
                          }
                      }))
                  },
                  scrollRenderAheadDistance: 1e3,
                  onEndReachedThreshold: 1e3,
                  stickySectionHeadersEnabled: !1,
                  stickyHeaderIndices: []
              }
          },
          getInitialState: function() {
              return {
                  curRenderedRowsCount: this.props.initialListSize,
                  highlightedRow: {}
              }
          },
          getInnerViewNode: function() {
              return this._scrollComponent && this._scrollComponent.getInnerViewNode()
          },
          UNSAFE_componentWillMount: function() {
              this.scrollProperties = {
                  visibleLength: null,
                  contentLength: null,
                  offset: 0
              }, this._rafIds = [], this._childFrames = [], this._visibleRows = {}, this._prevRenderedRowsCount = 0, this._sentEndForContentLength = null
          },
          componentWillUnmount: function() {
              this._rafIds.forEach(cancelAnimationFrame), this._rafIds = []
          },
          componentDidMount: function() {
              var t = this;
              this._requestAnimationFrame(function() {
                  t._measureAndUpdateScrollProps()
              })
          },
          UNSAFE_componentWillReceiveProps: function(t) {
              var o = this;
              this.props.dataSource === t.dataSource && this.props.initialListSize === t.initialListSize || this.setState(function(t, n) {
                  return o._prevRenderedRowsCount = 0, {
                      curRenderedRowsCount: Math.min(Math.max(t.curRenderedRowsCount, n.initialListSize), n.enableEmptySections ? n.dataSource.getRowAndSectionCount() : n.dataSource.getRowCount())
                  }
              }, function() {
                  return o._renderMoreRowsIfNeeded()
              })
          },
          componentDidUpdate: function() {
              var t = this;
              this._requestAnimationFrame(function() {
                  t._measureAndUpdateScrollProps()
              })
          },
          _onRowHighlighted: function(t, o) {
              this.setState({
                  highlightedRow: {
                      sectionID: t,
                      rowID: o
                  }
              })
          },
          render: function() {
              for (var s = [], h = this.props.dataSource, c = h.rowIdentities, p = 0, u = [], w = this.props.renderSectionHeader, S = this.props.renderHeader && this.props.renderHeader(), C = this.props.renderFooter && this.props.renderFooter(), v = S ? 1 : 0, b = 0; b < c.length; b++) {
                  var E = h.sectionIdentities[b],
                      y = c[b];
                  if (0 === y.length) {
                      if (void 0 === this.props.enableEmptySections) {
                          r(d[16])(!1, "In next release empty section headers will be rendered. In this release you can use 'enableEmptySections' flag to render empty section headers.");
                          continue
                      }
                      r(d[17])(this.props.enableEmptySections, "In next release 'enableEmptySections' flag will be deprecated, empty section headers will always be rendered. If empty section headers are not desirable their indices should be excluded from sectionIDs object. In this release 'enableEmptySections' may only have value 'true' to allow empty section headers rendering.")
                  }
                  if (w) {
                      var I = w(h.getSectionHeaderData(b), E);
                      I && (s.push(l.cloneElement(I, {
                          key: 's_' + E
                      })), this.props.stickySectionHeadersEnabled && u.push(v), v++)
                  }
                  for (var L = 0; L < y.length; L++) {
                      var P = y[L],
                          F = E + '_' + P,
                          N = p >= this._prevRenderedRowsCount && h.rowShouldUpdate(b, L),
                          D = l.createElement(_, {
                              key: 'r_' + F,
                              shouldUpdate: !!N,
                              render: this.props.renderRow.bind(null, h.getRowData(b, L), E, P, this._onRowHighlighted),
                              __source: {
                                  fileName: n,
                                  lineNumber: 463
                              }
                          });
                      if (s.push(D), v++, this.props.renderSeparator && (L !== y.length - 1 || b === c.length - 1)) {
                          var A = this.state.highlightedRow.sectionID === E && (this.state.highlightedRow.rowID === P || this.state.highlightedRow.rowID === y[L + 1]),
                              H = this.props.renderSeparator(E, P, A);
                          H && (s.push(l.createElement(R, {
                              key: 's_' + F,
                              __source: {
                                  fileName: n,
                                  lineNumber: 492
                              }
                          }, H)), v++)
                      }
                      if (++p === this.state.curRenderedRowsCount) break
                  }
                  if (p >= this.state.curRenderedRowsCount) break
              }
              var z = this.props,
                  V = z.renderScrollComponent,
                  k = t(z, ["renderScrollComponent"]);
              return k.scrollEventThrottle || (k.scrollEventThrottle = 50), void 0 === k.removeClippedSubviews && (k.removeClippedSubviews = !0), o(k, {
                  onScroll: this._onScroll,
                  stickyHeaderIndices: this.props.stickyHeaderIndices.concat(u),
                  onKeyboardWillShow: void 0,
                  onKeyboardWillHide: void 0,
                  onKeyboardDidShow: void 0,
                  onKeyboardDidHide: void 0
              }), f(V(k), {
                  ref: this._setScrollComponentRef,
                  onContentSizeChange: this._onContentSizeChange,
                  onLayout: this._onLayout,
                  DEPRECATED_sendUpdatedChildFrames: void 0 !== typeof k.onChangeVisibleRows
              }, S, s, C)
          },
          _requestAnimationFrame: function(t) {
              var o = this,
                  n = requestAnimationFrame(function() {
                      o._rafIds = o._rafIds.filter(function(t) {
                          return t !== n
                      }), t()
                  });
              this._rafIds.push(n)
          },
          _measureAndUpdateScrollProps: function() {
              var t = this.getScrollResponder();
              t && t.getInnerViewNode && c && c.calculateChildFrames && c.calculateChildFrames(h.findNodeHandle(t), this._updateVisibleRows)
          },
          _setScrollComponentRef: function(t) {
              this._scrollComponent = t
          },
          _onContentSizeChange: function(t, o) {
              var n = this.props.horizontal ? t : o;
              n !== this.scrollProperties.contentLength && (this.scrollProperties.contentLength = n, this._updateVisibleRows(), this._renderMoreRowsIfNeeded()), this.props.onContentSizeChange && this.props.onContentSizeChange(t, o)
          },
          _onLayout: function(t) {
              var o = t.nativeEvent.layout,
                  n = o.width,
                  s = o.height,
                  l = this.props.horizontal ? n : s;
              l !== this.scrollProperties.visibleLength && (this.scrollProperties.visibleLength = l, this._updateVisibleRows(), this._renderMoreRowsIfNeeded()), this.props.onLayout && this.props.onLayout(t)
          },
          _maybeCallOnEndReached: function(t) {
              return !!(this.props.onEndReached && this.scrollProperties.contentLength !== this._sentEndForContentLength && this._getDistanceFromEnd(this.scrollProperties) < this.props.onEndReachedThreshold && this.state.curRenderedRowsCount === (this.props.enableEmptySections ? this.props.dataSource.getRowAndSectionCount() : this.props.dataSource.getRowCount())) && (this._sentEndForContentLength = this.scrollProperties.contentLength, this.props.onEndReached(t), !0)
          },
          _renderMoreRowsIfNeeded: function() {
              null !== this.scrollProperties.contentLength && null !== this.scrollProperties.visibleLength && this.state.curRenderedRowsCount !== (this.props.enableEmptySections ? this.props.dataSource.getRowAndSectionCount() : this.props.dataSource.getRowCount()) ? this._getDistanceFromEnd(this.scrollProperties) < this.props.scrollRenderAheadDistance && this._pageInNewRows() : this._maybeCallOnEndReached()
          },
          _pageInNewRows: function() {
              var t = this;
              this.setState(function(o, n) {
                  var s = Math.min(o.curRenderedRowsCount + n.pageSize, n.enableEmptySections ? n.dataSource.getRowAndSectionCount() : n.dataSource.getRowCount());
                  return t._prevRenderedRowsCount = o.curRenderedRowsCount, {
                      curRenderedRowsCount: s
                  }
              }, function() {
                  t._measureAndUpdateScrollProps(), t._prevRenderedRowsCount = t.state.curRenderedRowsCount
              })
          },
          _getDistanceFromEnd: function(t) {
              return t.contentLength - t.visibleLength - t.offset
          },
          _updateVisibleRows: function(t) {
              var o = this;
              if (this.props.onChangeVisibleRows) {
                  t && t.forEach(function(t) {
                      o._childFrames[t.index] = C(t)
                  });
                  for (var n = !this.props.horizontal, s = this.props.dataSource, l = this.scrollProperties.offset, h = l + this.scrollProperties.visibleLength, c = s.rowIdentities, p = this.props.renderHeader && this.props.renderHeader() ? 1 : 0, u = !1, _ = {}, R = 0; R < c.length; R++) {
                      var f = c[R];
                      if (0 !== f.length) {
                          var w = s.sectionIdentities[R];
                          this.props.renderSectionHeader && p++;
                          var v = this._visibleRows[w];
                          v || (v = {});
                          for (var b = 0; b < f.length; b++) {
                              var E = f[b],
                                  y = this._childFrames[p];
                              if (p++, !this.props.renderSeparator || b === f.length - 1 && R !== c.length - 1 || p++, !y) break;
                              var I = v[E],
                                  L = n ? y.y : y.x,
                                  P = L + (n ? y.height : y.width);
                              if (!L && !P || L === P) break;
                              L > h || P < l ? I && (u = !0, delete v[E], _[w] || (_[w] = {}), _[w][E] = !1) : I || (u = !0, v[E] = !0, _[w] || (_[w] = {}), _[w][E] = !0)
                          }
                          S(v) ? this._visibleRows[w] && delete this._visibleRows[w] : this._visibleRows[w] = v
                      }
                  }
                  u && this.props.onChangeVisibleRows(this._visibleRows, _)
              }
          },
          _onScroll: function(t) {
              var o = !this.props.horizontal;
              this.scrollProperties.visibleLength = t.nativeEvent.layoutMeasurement[o ? 'height' : 'width'], this.scrollProperties.contentLength = t.nativeEvent.contentSize[o ? 'height' : 'width'], this.scrollProperties.offset = t.nativeEvent.contentOffset[o ? 'y' : 'x'], this._updateVisibleRows(t.nativeEvent.updatedChildFrames), this._maybeCallOnEndReached(t) || this._renderMoreRowsIfNeeded(), this.props.onEndReached && this._getDistanceFromEnd(this.scrollProperties) > this.props.onEndReachedThreshold && (this._sentEndForContentLength = null), this.props.onScroll && this.props.onScroll(t)
          }
      });
  m.exports = v
}