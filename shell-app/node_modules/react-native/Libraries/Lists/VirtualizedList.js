module.exports = function(g, r, i, a, m, e, d) {
  'use strict';
  var t = r(d[0]),
      s = r(d[1]),
      o = r(d[2]),
      n = r(d[3]),
      l = r(d[4]),
      c = r(d[5]),
      h = r(d[6]),
      u = r(d[7]),
      p = "/Users/linyiting/Desktop/Arrow/arrow/node_modules/react-native/Libraries/Lists/VirtualizedList.js";

  function f(t, s) {
      var o = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
          var n = Object.getOwnPropertySymbols(t);
          s && (n = n.filter(function(s) {
              return Object.getOwnPropertyDescriptor(t, s).enumerable
          })), o.push.apply(o, n)
      }
      return o
  }

  function _(t) {
      for (var o = 1; o < arguments.length; o++) {
          var n = null != arguments[o] ? arguments[o] : {};
          o % 2 ? f(n, !0).forEach(function(o) {
              s(t, o, n[o])
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : f(n).forEach(function(s) {
              Object.defineProperty(t, s, Object.getOwnPropertyDescriptor(n, s))
          })
      }
      return t
  }
  var y = r(d[8]),
      v = r(d[9]),
      C = r(d[10]),
      b = r(d[11]),
      L = r(d[12]),
      S = r(d[13]),
      M = r(d[14]),
      x = r(d[15]),
      k = r(d[16]),
      I = r(d[17]),
      N = r(d[18]),
      E = (r(d[19]), r(d[20])),
      w = r(d[21]),
      R = (r(d[22]), r(d[23]).computeWindowedRenderLimits),
      T = !1,
      O = '',
      z = (function(f) {
          function C(s, h) {
              var u;
              o(this, C), (u = n(this, l(C).call(this, s, h)))._getScrollMetrics = function() {
                  return u._scrollMetrics
              }, u._getOutermostParentListRef = function() {
                  return u._isNestedWithSameOrientation() ? u.context.virtualizedList.getOutermostParentListRef() : c(u)
              }, u._getNestedChildState = function(t) {
                  var s = u._nestedChildLists.get(t);
                  return s && s.state
              }, u._registerAsNestedChild = function(t) {
                  var s = u._cellKeysToChildListKeys.get(t.cellKey) || new Set;
                  s.add(t.key), u._cellKeysToChildListKeys.set(t.cellKey, s);
                  var o = u._nestedChildLists.get(t.key);
                  w(!(o && null !== o.ref), "A VirtualizedList contains a cell which itself contains more than one VirtualizedList of the same orientation as the parent list. You must pass a unique listKey prop to each sibling list."), u._nestedChildLists.set(t.key, {
                      ref: t.ref,
                      state: null
                  }), u._hasInteracted && t.ref.recordInteraction()
              }, u._unregisterAsNestedChild = function(t) {
                  u._nestedChildLists.set(t.key, {
                      ref: null,
                      state: t.state
                  })
              }, u._onUpdateSeparators = function(t, s) {
                  t.forEach(function(t) {
                      var o = null != t && u._cellRefs[t];
                      o && o.updateSeparatorProps(s)
                  })
              }, u._averageCellLength = 0, u._cellKeysToChildListKeys = new Map, u._cellRefs = {}, u._frames = {}, u._footerLength = 0, u._hasDataChangedSinceEndReached = !0, u._hasDoneInitialScroll = !1, u._hasInteracted = !1, u._hasMore = !1, u._hasWarned = {}, u._headerLength = 0, u._hiPriInProgress = !1, u._highestMeasuredFrameIndex = 0, u._indicesToKeys = new Map, u._nestedChildLists = new Map, u._offsetFromParentVirtualizedList = 0, u._prevParentOffset = 0, u._scrollMetrics = {
                  contentLength: 0,
                  dOffset: 0,
                  dt: 10,
                  offset: 0,
                  timestamp: 0,
                  velocity: 0,
                  visibleLength: 0
              }, u._scrollRef = null, u._sentEndForContentLength = 0, u._totalCellLength = 0, u._totalCellsMeasured = 0, u._viewabilityTuples = [], u._captureScrollRef = function(t) {
                  u._scrollRef = t
              }, u._defaultRenderScrollComponent = function(s) {
                  var o = s.onRefresh;
                  return u._isNestedWithSameOrientation() ? b.createElement(I, t({}, s, {
                      __source: {
                          fileName: p,
                          lineNumber: 1054
                      }
                  })) : o ? (w('boolean' == typeof s.refreshing, '`refreshing` prop must be set as a boolean in order to use `onRefresh`, but got `' + JSON.stringify(s.refreshing) + '`'), b.createElement(M, t({}, s, {
                      refreshControl: null == s.refreshControl ? b.createElement(S, {
                          refreshing: s.refreshing,
                          onRefresh: o,
                          progressViewOffset: s.progressViewOffset,
                          __source: {
                              fileName: p,
                              lineNumber: 1068
                          }
                      }) : s.refreshControl,
                      __source: {
                          fileName: p,
                          lineNumber: 1064
                      }
                  }))) : b.createElement(M, t({}, s, {
                      __source: {
                          fileName: p,
                          lineNumber: 1081
                      }
                  }))
              }, u._onCellUnmount = function(t) {
                  var s = u._frames[t];
                  s && (u._frames[t] = _({}, s, {
                      inLayout: !1
                  }))
              }, u._onLayout = function(t) {
                  u._isNestedWithSameOrientation() ? u.measureLayoutRelativeToContainingList() : u._scrollMetrics.visibleLength = u._selectLength(t.nativeEvent.layout), u.props.onLayout && u.props.onLayout(t), u._scheduleCellsToRenderUpdate(), u._maybeCallOnEndReached()
              }, u._onLayoutEmpty = function(t) {
                  u.props.onLayout && u.props.onLayout(t)
              }, u._onLayoutFooter = function(t) {
                  u._footerLength = u._selectLength(t.nativeEvent.layout)
              }, u._onLayoutHeader = function(t) {
                  u._headerLength = u._selectLength(t.nativeEvent.layout)
              }, u._onContentSizeChange = function(t, s) {
                  t > 0 && s > 0 && null != u.props.initialScrollIndex && u.props.initialScrollIndex > 0 && !u._hasDoneInitialScroll && (u.scrollToIndex({
                      animated: !1,
                      index: u.props.initialScrollIndex
                  }), u._hasDoneInitialScroll = !0), u.props.onContentSizeChange && u.props.onContentSizeChange(t, s), u._scrollMetrics.contentLength = u._selectLength({
                      height: s,
                      width: t
                  }), u._scheduleCellsToRenderUpdate(), u._maybeCallOnEndReached()
              }, u._convertParentScrollMetrics = function(t) {
                  var s = t.offset - u._offsetFromParentVirtualizedList,
                      o = t.visibleLength,
                      n = s - u._scrollMetrics.offset;
                  return {
                      visibleLength: o,
                      contentLength: u._scrollMetrics.contentLength,
                      offset: s,
                      dOffset: n
                  }
              }, u._onScroll = function(t) {
                  u._nestedChildLists.forEach(function(s) {
                      s.ref && s.ref._onScroll(t)
                  }), u.props.onScroll && u.props.onScroll(t);
                  var s = t.timeStamp,
                      o = u._selectLength(t.nativeEvent.layoutMeasurement),
                      n = u._selectLength(t.nativeEvent.contentSize),
                      l = u._selectOffset(t.nativeEvent.contentOffset),
                      c = l - u._scrollMetrics.offset;
                  if (u._isNestedWithSameOrientation()) {
                      if (0 === u._scrollMetrics.contentLength) return;
                      var h = u._convertParentScrollMetrics({
                          visibleLength: o,
                          offset: l
                      });
                      o = h.visibleLength, n = h.contentLength, l = h.offset, c = h.dOffset
                  }
                  var p = u._scrollMetrics.timestamp ? Math.max(1, s - u._scrollMetrics.timestamp) : 1,
                      f = c / p;
                  p > 500 && u._scrollMetrics.dt > 500 && n > 5 * o && !u._hasWarned.perf && (E("VirtualizedList: You have a large list that is slow to update - make sure your renderItem function renders components that follow React performance best practices like PureComponent, shouldComponentUpdate, etc.", {
                      dt: p,
                      prevDt: u._scrollMetrics.dt,
                      contentLength: n
                  }), u._hasWarned.perf = !0), u._scrollMetrics = {
                      contentLength: n,
                      dt: p,
                      dOffset: c,
                      offset: l,
                      timestamp: s,
                      velocity: f,
                      visibleLength: o
                  }, u._updateViewableItems(u.props.data), u.props && (u._maybeCallOnEndReached(), 0 !== f && u._fillRateHelper.activate(), u._computeBlankness(), u._scheduleCellsToRenderUpdate())
              }, u._onScrollBeginDrag = function(t) {
                  u._nestedChildLists.forEach(function(s) {
                      s.ref && s.ref._onScrollBeginDrag(t)
                  }), u._viewabilityTuples.forEach(function(t) {
                      t.viewabilityHelper.recordInteraction()
                  }), u._hasInteracted = !0, u.props.onScrollBeginDrag && u.props.onScrollBeginDrag(t)
              }, u._onScrollEndDrag = function(t) {
                  var s = t.nativeEvent.velocity;
                  s && (u._scrollMetrics.velocity = u._selectOffset(s)), u._computeBlankness(), u.props.onScrollEndDrag && u.props.onScrollEndDrag(t)
              }, u._onMomentumScrollEnd = function(t) {
                  u._scrollMetrics.velocity = 0, u._computeBlankness(), u.props.onMomentumScrollEnd && u.props.onMomentumScrollEnd(t)
              }, u._updateCellsToRender = function() {
                  var t = u.props,
                      s = t.data,
                      o = t.getItemCount,
                      n = t.onEndReachedThreshold,
                      l = u._isVirtualizationDisabled();
                  u._updateViewableItems(s), s && u.setState(function(t) {
                      var c;
                      if (l) {
                          var h = u._scrollMetrics,
                              p = h.contentLength,
                              f = h.offset,
                              _ = h.visibleLength,
                              y = p - _ - f < n * _ ? u.props.maxToRenderPerBatch : 0;
                          c = {
                              first: 0,
                              last: Math.min(t.last + y, o(s) - 1)
                          }
                      } else u._scrollMetrics.visibleLength && (u.props.initialScrollIndex && !u._scrollMetrics.offset || (c = R(u.props, t, u._getFrameMetricsApprox, u._scrollMetrics)));
                      if (c && u._nestedChildLists.size > 0)
                          for (var v = c.first, C = c.last, b = v; b <= C; b++) {
                              var L = u._indicesToKeys.get(b),
                                  S = L && u._cellKeysToChildListKeys.get(L);
                              if (S) {
                                  var M = !1,
                                      x = S,
                                      k = Array.isArray(x),
                                      I = 0;
                                  for (x = k ? x : x["function" == typeof Symbol && "function" == typeof Symbol ? Symbol.iterator : "@@iterator"]();;) {
                                      var N;
                                      if (k) {
                                          if (I >= x.length) break;
                                          N = x[I++]
                                      } else {
                                          if ((I = x.next()).done) break;
                                          N = I.value
                                      }
                                      var E = N,
                                          w = u._nestedChildLists.get(E);
                                      if (w && w.ref && w.ref.hasMore()) {
                                          M = !0;
                                          break
                                      }
                                  }
                                  if (M) {
                                      c.last = b;
                                      break
                                  }
                              }
                          }
                      return c
                  })
              }, u._createViewToken = function(t, s) {
                  var o = u.props,
                      n = o.data,
                      l = o.getItem,
                      c = o.keyExtractor,
                      h = l(n, t);
                  return {
                      index: t,
                      item: h,
                      key: c(h, t),
                      isViewable: s
                  }
              }, u._getFrameMetricsApprox = function(t) {
                  var s = u._getFrameMetrics(t);
                  if (s && s.index === t) return s;
                  var o = u.props.getItemLayout;
                  return w(!o, 'Should not have to estimate frames when a measurement metrics function is provided'), {
                      length: u._averageCellLength,
                      offset: u._averageCellLength * t
                  }
              }, u._getFrameMetrics = function(t) {
                  var s = u.props,
                      o = s.data,
                      n = s.getItem,
                      l = s.getItemCount,
                      c = s.getItemLayout,
                      h = s.keyExtractor;
                  w(l(o) > t, 'Tried to get frame for out of range index ' + t);
                  var p = n(o, t),
                      f = p && u._frames[h(p, t)];
                  return f && f.index === t || c && (f = c(o, t)), f
              }, w(!s.onScroll || !s.onScroll.__isNative, "Components based on VirtualizedList must be wrapped with Animated.createAnimatedComponent to support native onScroll events with useNativeDriver"), w(s.windowSize > 0, 'VirtualizedList: The windowSize prop must be present and set to a value greater than 0.'), u._fillRateHelper = new v(u._getFrameMetrics), u._updateCellsToRenderBatcher = new y(u._updateCellsToRender, u.props.updateCellsBatchingPeriod), u.props.viewabilityConfigCallbackPairs ? u._viewabilityTuples = u.props.viewabilityConfigCallbackPairs.map(function(t) {
                  return {
                      viewabilityHelper: new N(t.viewabilityConfig),
                      onViewableItemsChanged: t.onViewableItemsChanged
                  }
              }) : u.props.onViewableItemsChanged && u._viewabilityTuples.push({
                  viewabilityHelper: new N(u.props.viewabilityConfig),
                  onViewableItemsChanged: u.props.onViewableItemsChanged
              });
              var f = {
                  first: u.props.initialScrollIndex || 0,
                  last: Math.min(u.props.getItemCount(u.props.data), (u.props.initialScrollIndex || 0) + u.props.initialNumToRender) - 1
              };
              if (u._isNestedWithSameOrientation()) {
                  var L = u.context.virtualizedList.getNestedChildState(u.props.listKey || u._getCellKey());
                  L && (f = L, u.state = L, u._frames = L.frames)
              }
              return u.state = f, u
          }
          return u(C, f), h(C, [{
              key: "scrollToEnd",
              value: function(t) {
                  var s = !t || t.animated,
                      o = this.props.getItemCount(this.props.data) - 1,
                      n = this._getFrameMetricsApprox(o),
                      l = Math.max(0, n.offset + n.length + this._footerLength - this._scrollMetrics.visibleLength);
                  this._scrollRef.scrollTo(this.props.horizontal ? {
                      x: l,
                      animated: s
                  } : {
                      y: l,
                      animated: s
                  })
              }
          }, {
              key: "scrollToIndex",
              value: function(t) {
                  var s = this.props,
                      o = s.data,
                      n = s.horizontal,
                      l = s.getItemCount,
                      c = s.getItemLayout,
                      h = s.onScrollToIndexFailed,
                      u = t.animated,
                      p = t.index,
                      f = t.viewOffset,
                      _ = t.viewPosition;
                  if (w(p >= 0 && p < l(o), "scrollToIndex out of range: " + p + " vs " + (l(o) - 1)), !c && p > this._highestMeasuredFrameIndex) return w(!!h, "scrollToIndex should be used in conjunction with getItemLayout or onScrollToIndexFailed, otherwise there is no way to know the location of offscreen indices or handle failures."), void h({
                      averageItemLength: this._averageCellLength,
                      highestMeasuredFrameIndex: this._highestMeasuredFrameIndex,
                      index: p
                  });
                  var y = this._getFrameMetricsApprox(p),
                      v = Math.max(0, y.offset - (_ || 0) * (this._scrollMetrics.visibleLength - y.length)) - (f || 0);
                  this._scrollRef.scrollTo(n ? {
                      x: v,
                      animated: u
                  } : {
                      y: v,
                      animated: u
                  })
              }
          }, {
              key: "scrollToItem",
              value: function(t) {
                  for (var s = t.item, o = this.props, n = o.data, l = o.getItem, c = (0, o.getItemCount)(n), h = 0; h < c; h++)
                      if (l(n, h) === s) {
                          this.scrollToIndex(_({}, t, {
                              index: h
                          }));
                          break
                      }
              }
          }, {
              key: "scrollToOffset",
              value: function(t) {
                  var s = t.animated,
                      o = t.offset;
                  this._scrollRef.scrollTo(this.props.horizontal ? {
                      x: o,
                      animated: s
                  } : {
                      y: o,
                      animated: s
                  })
              }
          }, {
              key: "recordInteraction",
              value: function() {
                  this._nestedChildLists.forEach(function(t) {
                      t.ref && t.ref.recordInteraction()
                  }), this._viewabilityTuples.forEach(function(t) {
                      t.viewabilityHelper.recordInteraction()
                  }), this._updateViewableItems(this.props.data)
              }
          }, {
              key: "flashScrollIndicators",
              value: function() {
                  this._scrollRef.flashScrollIndicators()
              }
          }, {
              key: "getScrollResponder",
              value: function() {
                  if (this._scrollRef && this._scrollRef.getScrollResponder) return this._scrollRef.getScrollResponder()
              }
          }, {
              key: "getScrollableNode",
              value: function() {
                  return this._scrollRef && this._scrollRef.getScrollableNode ? this._scrollRef.getScrollableNode() : L.findNodeHandle(this._scrollRef)
              }
          }, {
              key: "setNativeProps",
              value: function(t) {
                  this._scrollRef && this._scrollRef.setNativeProps(t)
              }
          }, {
              key: "getChildContext",
              value: function() {
                  return {
                      virtualizedList: {
                          getScrollMetrics: this._getScrollMetrics,
                          horizontal: this.props.horizontal,
                          getOutermostParentListRef: this._getOutermostParentListRef,
                          getNestedChildState: this._getNestedChildState,
                          registerAsNestedChild: this._registerAsNestedChild,
                          unregisterAsNestedChild: this._unregisterAsNestedChild
                      }
                  }
              }
          }, {
              key: "_getCellKey",
              value: function() {
                  return this.context.virtualizedCell && this.context.virtualizedCell.cellKey || 'rootList'
              }
          }, {
              key: "hasMore",
              value: function() {
                  return this._hasMore
              }
          }]), h(C, [{
              key: "componentDidMount",
              value: function() {
                  this._isNestedWithSameOrientation() && this.context.virtualizedList.registerAsNestedChild({
                      cellKey: this._getCellKey(),
                      key: this.props.listKey || this._getCellKey(),
                      ref: this
                  })
              }
          }, {
              key: "componentWillUnmount",
              value: function() {
                  this._isNestedWithSameOrientation() && this.context.virtualizedList.unregisterAsNestedChild({
                      key: this.props.listKey || this._getCellKey(),
                      state: {
                          first: this.state.first,
                          last: this.state.last,
                          frames: this._frames
                      }
                  }), this._updateViewableItems(null), this._updateCellsToRenderBatcher.dispose({
                      abort: !0
                  }), this._viewabilityTuples.forEach(function(t) {
                      t.viewabilityHelper.dispose()
                  }), this._fillRateHelper.deactivateAndFlush()
              }
          }, {
              key: "_pushCells",
              value: function(t, s, o, n, l, c) {
                  var h, u = this,
                      f = this.props,
                      _ = f.CellRendererComponent,
                      y = f.ItemSeparatorComponent,
                      v = f.data,
                      C = f.getItem,
                      L = f.getItemCount,
                      S = f.horizontal,
                      M = f.keyExtractor,
                      x = this.props.ListHeaderComponent ? 1 : 0,
                      k = L(v) - 1;
                  l = Math.min(k, l);
                  for (var I = function(n) {
                          var l = C(v, n),
                              f = M(l, n);
                          u._indicesToKeys.set(n, f), o.has(n + x) && s.push(t.length), t.push(b.createElement(P, {
                              CellRendererComponent: _,
                              ItemSeparatorComponent: n < k ? y : void 0,
                              cellKey: f,
                              fillRateHelper: u._fillRateHelper,
                              horizontal: S,
                              index: n,
                              inversionStyle: c,
                              item: l,
                              key: f,
                              prevCellKey: h,
                              onUpdateSeparators: u._onUpdateSeparators,
                              onLayout: function(t) {
                                  return u._onCellLayout(t, f, n)
                              },
                              onUnmount: u._onCellUnmount,
                              parentProps: u.props,
                              ref: function(t) {
                                  u._cellRefs[f] = t
                              },
                              __source: {
                                  fileName: p,
                                  lineNumber: 688
                              }
                          })), h = f
                      }, N = n; N <= l; N++) I(N)
              }
          }, {
              key: "_isVirtualizationDisabled",
              value: function() {
                  return this.props.disableVirtualization
              }
          }, {
              key: "_isNestedWithSameOrientation",
              value: function() {
                  var t = this.context.virtualizedList;
                  return !(!t || !!t.horizontal != !!this.props.horizontal)
              }
          }, {
              key: "render",
              value: function() {
                  var t = this,
                      o = this.props,
                      n = o.ListEmptyComponent,
                      l = o.ListFooterComponent,
                      c = o.ListHeaderComponent,
                      h = this.props,
                      u = h.data,
                      f = h.horizontal,
                      y = this._isVirtualizationDisabled(),
                      v = this.props.inverted ? this.props.horizontal ? K.horizontallyInverted : K.verticallyInverted : null,
                      C = [],
                      L = new Set(this.props.stickyHeaderIndices),
                      S = [];
                  if (c) {
                      L.has(0) && S.push(0);
                      var M = b.isValidElement(c) ? c : b.createElement(c, {
                          __source: {
                              fileName: p,
                              lineNumber: 762
                          }
                      });
                      C.push(b.createElement(F, {
                          cellKey: this._getCellKey() + '-header',
                          key: "$header",
                          __source: {
                              fileName: p,
                              lineNumber: 765
                          }
                      }, b.createElement(I, {
                          onLayout: this._onLayoutHeader,
                          style: x.compose(v, this.props.ListHeaderComponentStyle),
                          __source: {
                              fileName: p,
                              lineNumber: 768
                          }
                      }, M)))
                  }
                  var k = this.props.getItemCount(u);
                  if (k > 0) {
                      T = !1, O = '';
                      var N = f ? 'width' : 'height',
                          E = this.props.initialScrollIndex ? -1 : this.props.initialNumToRender - 1,
                          w = this.state,
                          R = w.first,
                          z = w.last;
                      this._pushCells(C, S, L, 0, E, v);
                      var P = Math.max(E + 1, R);
                      if (!y && R > E + 1) {
                          var V = !1;
                          if (L.size > 0)
                              for (var A = c ? 1 : 0, D = P - 1; D > E; D--)
                                  if (L.has(D + A)) {
                                      var H = this._getFrameMetricsApprox(E),
                                          B = this._getFrameMetricsApprox(D),
                                          U = B.offset - H.offset - (this.props.initialScrollIndex ? 0 : H.length);
                                      C.push(b.createElement(I, {
                                          key: "$sticky_lead",
                                          style: s({}, N, U),
                                          __source: {
                                              fileName: p,
                                              lineNumber: 814
                                          }
                                      })), this._pushCells(C, S, L, D, D, v);
                                      var W = this._getFrameMetricsApprox(R).offset - (B.offset + B.length);
                                      C.push(b.createElement(I, {
                                          key: "$sticky_trail",
                                          style: s({}, N, W),
                                          __source: {
                                              fileName: p,
                                              lineNumber: 828
                                          }
                                      })), V = !0;
                                      break
                                  } if (!V) {
                              var j = this._getFrameMetricsApprox(E),
                                  $ = this._getFrameMetricsApprox(R).offset - (j.offset + j.length);
                              C.push(b.createElement(I, {
                                  key: "$lead_spacer",
                                  style: s({}, N, $),
                                  __source: {
                                      fileName: p,
                                      lineNumber: 841
                                  }
                              }))
                          }
                      }
                      if (this._pushCells(C, S, L, P, z, v), !this._hasWarned.keys && T && (console.warn("VirtualizedList: missing keys for items, make sure to specify a key property on each item or provide a custom keyExtractor.", O), this._hasWarned.keys = !0), !y && z < k - 1) {
                          var Y = this._getFrameMetricsApprox(z),
                              q = this.props.getItemLayout ? k - 1 : Math.min(k - 1, this._highestMeasuredFrameIndex),
                              J = this._getFrameMetricsApprox(q),
                              X = J.offset + J.length - (Y.offset + Y.length);
                          C.push(b.createElement(I, {
                              key: "$tail_spacer",
                              style: s({}, N, X),
                              __source: {
                                  fileName: p,
                                  lineNumber: 875
                              }
                          }))
                      }
                  } else if (n) {
                      var G = b.isValidElement(n) ? n : b.createElement(n, {
                          __source: {
                              fileName: p,
                              lineNumber: 885
                          }
                      });
                      C.push(b.cloneElement(G, {
                          key: '$empty',
                          onLayout: function(s) {
                              t._onLayoutEmpty(s), G.props.onLayout && G.props.onLayout(s)
                          },
                          style: x.compose(v, G.props.style)
                      }))
                  }
                  if (l) {
                      var Q = b.isValidElement(l) ? l : b.createElement(l, {
                          __source: {
                              fileName: p,
                              lineNumber: 908
                          }
                      });
                      C.push(b.createElement(F, {
                          cellKey: this._getCellKey() + '-footer',
                          key: "$footer",
                          __source: {
                              fileName: p,
                              lineNumber: 911
                          }
                      }, b.createElement(I, {
                          onLayout: this._onLayoutFooter,
                          style: x.compose(v, this.props.ListFooterComponentStyle),
                          __source: {
                              fileName: p,
                              lineNumber: 914
                          }
                      }, Q)))
                  }
                  var Z = _({}, this.props, {
                      onContentSizeChange: this._onContentSizeChange,
                      onLayout: this._onLayout,
                      onScroll: this._onScroll,
                      onScrollBeginDrag: this._onScrollBeginDrag,
                      onScrollEndDrag: this._onScrollEndDrag,
                      onMomentumScrollEnd: this._onMomentumScrollEnd,
                      scrollEventThrottle: this.props.scrollEventThrottle,
                      invertStickyHeaders: void 0 !== this.props.invertStickyHeaders ? this.props.invertStickyHeaders : this.props.inverted,
                      stickyHeaderIndices: S
                  });
                  v && (Z.style = [v, this.props.style]), this._hasMore = this.state.last < this.props.getItemCount(this.props.data) - 1;
                  var ee = b.cloneElement((this.props.renderScrollComponent || this._defaultRenderScrollComponent)(Z), {
                      ref: this._captureScrollRef
                  }, C);
                  return this.props.debug ? b.createElement(I, {
                      style: K.debug,
                      __source: {
                          fileName: p,
                          lineNumber: 964
                      }
                  }, ee, this._renderDebugOverlay()) : ee
              }
          }, {
              key: "componentDidUpdate",
              value: function(t) {
                  var s = this.props,
                      o = s.data,
                      n = s.extraData;
                  o === t.data && n === t.extraData || (this._hasDataChangedSinceEndReached = !0, this._viewabilityTuples.forEach(function(t) {
                      t.viewabilityHelper.resetViewableIndices()
                  }));
                  var l = this._hiPriInProgress;
                  this._scheduleCellsToRenderUpdate(), l && (this._hiPriInProgress = !1)
              }
          }, {
              key: "_computeBlankness",
              value: function() {
                  this._fillRateHelper.computeBlankness(this.props, this.state, this._scrollMetrics)
              }
          }, {
              key: "_onCellLayout",
              value: function(t, s, o) {
                  var n = t.nativeEvent.layout,
                      l = {
                          offset: this._selectOffset(n),
                          length: this._selectLength(n),
                          index: o,
                          inLayout: !0
                      },
                      c = this._frames[s];
                  c && l.offset === c.offset && l.length === c.length && o === c.index ? this._frames[s].inLayout = !0 : (this._totalCellLength += l.length - (c ? c.length : 0), this._totalCellsMeasured += c ? 0 : 1, this._averageCellLength = this._totalCellLength / this._totalCellsMeasured, this._frames[s] = l, this._highestMeasuredFrameIndex = Math.max(this._highestMeasuredFrameIndex, o), this._scheduleCellsToRenderUpdate());
                  var h = this._cellKeysToChildListKeys.get(s);
                  if (h) {
                      var u = h,
                          p = Array.isArray(u),
                          f = 0;
                      for (u = p ? u : u["function" == typeof Symbol ? Symbol.iterator : "@@iterator"]();;) {
                          var _;
                          if (p) {
                              if (f >= u.length) break;
                              _ = u[f++]
                          } else {
                              if ((f = u.next()).done) break;
                              _ = f.value
                          }
                          var y = _,
                              v = this._nestedChildLists.get(y);
                          v && v.ref && v.ref.measureLayoutRelativeToContainingList()
                      }
                  }
                  this._computeBlankness(), this._updateViewableItems(this.props.data)
              }
          }, {
              key: "measureLayoutRelativeToContainingList",
              value: function() {
                  var t = this;
                  try {
                      k.measureLayout(L.findNodeHandle(this), L.findNodeHandle(this.context.virtualizedList.getOutermostParentListRef()), function(t) {
                          console.warn("VirtualizedList: Encountered an error while measuring a list's offset from its containing VirtualizedList.")
                      }, function(s, o, n, l) {
                          t._offsetFromParentVirtualizedList = t._selectOffset({
                              x: s,
                              y: o
                          }), t._scrollMetrics.contentLength = t._selectLength({
                              width: n,
                              height: l
                          });
                          var c = t._convertParentScrollMetrics(t.context.virtualizedList.getScrollMetrics());
                          t._scrollMetrics.visibleLength = c.visibleLength, t._scrollMetrics.offset = c.offset
                      })
                  } catch (t) {
                      console.warn('measureLayoutRelativeToContainingList threw an error', t.stack)
                  }
              }
          }, {
              key: "_renderDebugOverlay",
              value: function() {
                  for (var t = this._scrollMetrics.visibleLength / (this._scrollMetrics.contentLength || 1), s = [], o = this.props.getItemCount(this.props.data), n = 0; n < o; n++) {
                      var l = this._getFrameMetricsApprox(n);
                      l.inLayout && s.push(l)
                  }
                  var c = this._getFrameMetricsApprox(this.state.first).offset,
                      h = this._getFrameMetricsApprox(this.state.last),
                      u = h.offset + h.length - c,
                      f = this._scrollMetrics.offset,
                      _ = this._scrollMetrics.visibleLength;
                  return b.createElement(I, {
                      style: [K.debugOverlayBase, K.debugOverlay],
                      __source: {
                          fileName: p,
                          lineNumber: 1221
                      }
                  }, s.map(function(s, o) {
                      return b.createElement(I, {
                          key: 'f' + o,
                          style: [K.debugOverlayBase, K.debugOverlayFrame, {
                              top: s.offset * t,
                              height: s.length * t
                          }],
                          __source: {
                              fileName: p,
                              lineNumber: 1223
                          }
                      })
                  }), b.createElement(I, {
                      style: [K.debugOverlayBase, K.debugOverlayFrameLast, {
                          top: c * t,
                          height: u * t
                      }],
                      __source: {
                          fileName: p,
                          lineNumber: 1235
                      }
                  }), b.createElement(I, {
                      style: [K.debugOverlayBase, K.debugOverlayFrameVis, {
                          top: f * t,
                          height: _ * t
                      }],
                      __source: {
                          fileName: p,
                          lineNumber: 1245
                      }
                  }))
              }
          }, {
              key: "_selectLength",
              value: function(t) {
                  return this.props.horizontal ? t.width : t.height
              }
          }, {
              key: "_selectOffset",
              value: function(t) {
                  return this.props.horizontal ? t.x : t.y
              }
          }, {
              key: "_maybeCallOnEndReached",
              value: function() {
                  var t = this.props,
                      s = t.data,
                      o = t.getItemCount,
                      n = t.onEndReached,
                      l = t.onEndReachedThreshold,
                      c = this._scrollMetrics,
                      h = c.contentLength,
                      u = c.visibleLength,
                      p = h - u - c.offset;
                  n && this.state.last === o(s) - 1 && p < l * u && (this._hasDataChangedSinceEndReached || this._scrollMetrics.contentLength !== this._sentEndForContentLength) && (this._hasDataChangedSinceEndReached = !1, this._sentEndForContentLength = this._scrollMetrics.contentLength, n({
                      distanceFromEnd: p
                  }))
              }
          }, {
              key: "_scheduleCellsToRenderUpdate",
              value: function() {
                  var t = this.state,
                      s = t.first,
                      o = t.last,
                      n = this._scrollMetrics,
                      l = n.offset,
                      c = n.visibleLength,
                      h = n.velocity,
                      u = this.props.getItemCount(this.props.data),
                      p = !1,
                      f = this.props.onEndReachedThreshold * c / 2;
                  if (s > 0) {
                      var _ = l - this._getFrameMetricsApprox(s).offset;
                      p = p || _ < 0 || h < -2 && _ < f
                  }
                  if (o < u - 1) {
                      var y = this._getFrameMetricsApprox(o).offset - (l + c);
                      p = p || y < 0 || h > 2 && y < f
                  }
                  if (p && this._averageCellLength && !this._hiPriInProgress) return this._hiPriInProgress = !0, this._updateCellsToRenderBatcher.dispose({
                      abort: !0
                  }), void this._updateCellsToRender();
                  this._updateCellsToRenderBatcher.schedule()
              }
          }, {
              key: "_updateViewableItems",
              value: function(t) {
                  var s = this,
                      o = this.props.getItemCount;
                  this._viewabilityTuples.forEach(function(n) {
                      n.viewabilityHelper.onUpdate(o(t), s._scrollMetrics.offset, s._scrollMetrics.visibleLength, s._getFrameMetrics, s._createViewToken, n.onViewableItemsChanged, s.state)
                  })
              }
          }], [{
              key: "getDerivedStateFromProps",
              value: function(t, s) {
                  var o = t.data,
                      n = t.getItemCount,
                      l = t.maxToRenderPerBatch;
                  return {
                      first: Math.max(0, Math.min(s.first, n(o) - 1 - l)),
                      last: Math.max(0, Math.min(s.last, n(o) - 1))
                  }
              }
          }]), C
      })(b.PureComponent);
  z.defaultProps = {
      disableVirtualization: !1,
      horizontal: !1,
      initialNumToRender: 10,
      keyExtractor: function(t, s) {
          return null != t.key ? t.key : (T = !0, t.type && t.type.displayName && (O = t.type.displayName), String(s))
      },
      maxToRenderPerBatch: 10,
      onEndReachedThreshold: 2,
      scrollEventThrottle: 50,
      updateCellsBatchingPeriod: 50,
      windowSize: 21
  }, z.contextTypes = {
      virtualizedCell: C.shape({
          cellKey: C.string
      }),
      virtualizedList: C.shape({
          getScrollMetrics: C.func,
          horizontal: C.bool,
          getOutermostParentListRef: C.func,
          getNestedChildState: C.func,
          registerAsNestedChild: C.func,
          unregisterAsNestedChild: C.func
      })
  }, z.childContextTypes = {
      virtualizedList: C.shape({
          getScrollMetrics: C.func,
          horizontal: C.bool,
          getOutermostParentListRef: C.func,
          getNestedChildState: C.func,
          registerAsNestedChild: C.func,
          unregisterAsNestedChild: C.func
      })
  };
  var P = (function(s) {
      function c() {
          var t, s;
          o(this, c);
          for (var h = arguments.length, u = new Array(h), p = 0; p < h; p++) u[p] = arguments[p];
          return (s = n(this, (t = l(c)).call.apply(t, [this].concat(u)))).state = {
              separatorProps: {
                  highlighted: !1,
                  leadingItem: s.props.item
              }
          }, s._separators = {
              highlight: function() {
                  var t = s.props,
                      o = t.cellKey,
                      n = t.prevCellKey;
                  s.props.onUpdateSeparators([o, n], {
                      highlighted: !0
                  })
              },
              unhighlight: function() {
                  var t = s.props,
                      o = t.cellKey,
                      n = t.prevCellKey;
                  s.props.onUpdateSeparators([o, n], {
                      highlighted: !1
                  })
              },
              updateProps: function(t, o) {
                  var n = s.props,
                      l = n.cellKey,
                      c = n.prevCellKey;
                  s.props.onUpdateSeparators(['leading' === t ? c : l], o)
              }
          }, s
      }
      return u(c, s), h(c, [{
          key: "getChildContext",
          value: function() {
              return {
                  virtualizedCell: {
                      cellKey: this.props.cellKey
                  }
              }
          }
      }, {
          key: "updateSeparatorProps",
          value: function(t) {
              this.setState(function(s) {
                  return {
                      separatorProps: _({}, s.separatorProps, {}, t)
                  }
              })
          }
      }, {
          key: "componentWillUnmount",
          value: function() {
              this.props.onUnmount(this.props.cellKey)
          }
      }, {
          key: "render",
          value: function() {
              var s = this.props,
                  o = s.CellRendererComponent,
                  n = s.ItemSeparatorComponent,
                  l = s.fillRateHelper,
                  c = s.horizontal,
                  h = s.item,
                  u = s.index,
                  f = s.inversionStyle,
                  _ = s.parentProps,
                  y = _.renderItem,
                  v = _.getItemLayout;
              w(y, 'no renderItem!');
              var C = y({
                      item: h,
                      index: u,
                      separators: this._separators
                  }),
                  L = !v || _.debug || l.enabled() ? this.props.onLayout : void 0,
                  S = n && b.createElement(n, t({}, this.state.separatorProps, {
                      __source: {
                          fileName: p,
                          lineNumber: 1748
                      }
                  })),
                  M = f ? c ? [{
                      flexDirection: 'row-reverse'
                  }, f] : [{
                      flexDirection: 'column-reverse'
                  }, f] : c ? [{
                      flexDirection: 'row'
                  }, f] : f;
              return o ? b.createElement(o, t({}, this.props, {
                  style: M,
                  onLayout: L,
                  __source: {
                      fileName: p,
                      lineNumber: 1769
                  }
              }), C, S) : b.createElement(I, {
                  style: M,
                  onLayout: L,
                  __source: {
                      fileName: p,
                      lineNumber: 1762
                  }
              }, C, S)
          }
      }]), c
  })(b.Component);
  P.childContextTypes = {
      virtualizedCell: C.shape({
          cellKey: C.string
      })
  };
  var F = (function(t) {
      function s() {
          return o(this, s), n(this, l(s).apply(this, arguments))
      }
      return u(s, t), h(s, [{
          key: "getChildContext",
          value: function() {
              return {
                  virtualizedCell: {
                      cellKey: this.props.cellKey
                  }
              }
          }
      }, {
          key: "render",
          value: function() {
              return this.props.children
          }
      }]), s
  })(b.Component);
  F.childContextTypes = {
      virtualizedCell: C.shape({
          cellKey: C.string
      })
  };
  var K = x.create({
      verticallyInverted: {
          transform: [{
              scaleY: -1
          }]
      },
      horizontallyInverted: {
          transform: [{
              scaleX: -1
          }]
      },
      debug: {
          flex: 1
      },
      debugOverlayBase: {
          position: 'absolute',
          top: 0,
          right: 0
      },
      debugOverlay: {
          bottom: 0,
          width: 20,
          borderColor: 'blue',
          borderWidth: 1
      },
      debugOverlayFrame: {
          left: 0,
          backgroundColor: 'orange'
      },
      debugOverlayFrameLast: {
          left: 0,
          borderColor: 'green',
          borderWidth: 2
      },
      debugOverlayFrameVis: {
          left: 0,
          borderColor: 'red',
          borderWidth: 2
      }
  });
  m.exports = z
}