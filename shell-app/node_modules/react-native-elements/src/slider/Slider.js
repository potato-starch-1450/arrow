module.exports = function(g, r, i, a, m, e, d) {
  var t = r(d[0]),
      n = r(d[1]);
  Object.defineProperty(e, "__esModule", {
      value: !0
  }), e.default = e.Slider = void 0;
  var u = t(r(d[2])),
      o = t(r(d[3])),
      h = t(r(d[4])),
      l = t(r(d[5])),
      s = t(r(d[6])),
      c = t(r(d[7])),
      p = t(r(d[8])),
      f = t(r(d[9])),
      b = t(r(d[10])),
      v = t(r(d[11])),
      S = n(r(d[12])),
      y = t(r(d[13])),
      T = r(d[14]),
      w = r(d[15]),
      k = "/Users/linyiting/Desktop/Arrow/arrow/node_modules/react-native-elements/src/slider/Slider.js";

  function V(t, n) {
      var u = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(t);
          n && (o = o.filter(function(n) {
              return Object.getOwnPropertyDescriptor(t, n).enumerable
          })), u.push.apply(u, o)
      }
      return u
  }

  function z(t) {
      for (var n = 1; n < arguments.length; n++) {
          var u = null != arguments[n] ? arguments[n] : {};
          n % 2 ? V(u, !0).forEach(function(n) {
              (0, o.default)(t, n, u[n])
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(u)) : V(u).forEach(function(n) {
              Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(u, n))
          })
      }
      return t
  }
  var C = {
          spring: {
              friction: 7,
              tension: 100
          },
          timing: {
              duration: 150,
              easing: T.Easing.inOut(T.Easing.ease),
              delay: 0
          }
      },
      P = function(t) {
          var n = t.value,
              u = t.maximumValue,
              o = t.minimumValue;
          return n > u ? u : n < o ? o : n
      },
      R = (function() {
          function t(n, u, o, h) {
              (0, b.default)(this, t), this.x = n, this.y = u, this.width = o, this.height = h
          }
          return (0, v.default)(t, [{
              key: "containsPoint",
              value: function(t, n) {
                  return t >= this.x && n >= this.y && t <= this.x + this.width && n <= this.y + this.height
              }
          }]), t
      })(),
      _ = (function(t) {
          function n(t) {
              var u;
              return (0, b.default)(this, n), (u = (0, s.default)(this, (0, c.default)(n).call(this, t))).measureContainer = function(t) {
                  u.handleMeasure('containerSize', t)
              }, u.measureTrack = function(t) {
                  u.handleMeasure('trackSize', t)
              }, u.measureThumb = function(t) {
                  u.handleMeasure('thumbSize', t)
              }, u.state = {
                  containerSize: {
                      width: 0,
                      height: 0
                  },
                  trackSize: {
                      width: 0,
                      height: 0
                  },
                  thumbSize: {
                      width: 0,
                      height: 0
                  },
                  allMeasured: !1,
                  value: new T.Animated.Value(P(t))
              }, u.panResponder = T.PanResponder.create({
                  onStartShouldSetPanResponder: u.handleStartShouldSetPanResponder.bind((0, p.default)(u)),
                  onMoveShouldSetPanResponder: u.handleMoveShouldSetPanResponder.bind((0, p.default)(u)),
                  onPanResponderGrant: u.handlePanResponderGrant.bind((0, p.default)(u)),
                  onPanResponderMove: u.handlePanResponderMove.bind((0, p.default)(u)),
                  onPanResponderRelease: u.handlePanResponderEnd.bind((0, p.default)(u)),
                  onPanResponderTerminationRequest: u.handlePanResponderRequestEnd.bind((0, p.default)(u)),
                  onPanResponderTerminate: u.handlePanResponderEnd.bind((0, p.default)(u))
              }), u
          }
          return (0, f.default)(n, t), (0, v.default)(n, [{
              key: "componentDidUpdate",
              value: function(t) {
                  var n = P(this.props);
                  t.value !== n && (this.props.animateTransitions ? this.setCurrentValueAnimated(n) : this.setCurrentValue(n))
              }
          }, {
              key: "setCurrentValue",
              value: function(t) {
                  this.state.value.setValue(t)
              }
          }, {
              key: "setCurrentValueAnimated",
              value: function(t) {
                  var n = this.props.animationType,
                      u = (0, l.default)({}, C[n], this.props.animationConfig, {
                          toValue: t
                      });
                  T.Animated[n](this.state.value, u).start()
              }
          }, {
              key: "handleMoveShouldSetPanResponder",
              value: function() {
                  return !1
              }
          }, {
              key: "handlePanResponderGrant",
              value: function() {
                  this._previousLeft = this.getThumbLeft(this.getCurrentValue()), this.fireChangeEvent('onSlidingStart')
              }
          }, {
              key: "handlePanResponderMove",
              value: function(t, n) {
                  this.props.disabled || (this.setCurrentValue(this.getValue(n)), this.fireChangeEvent('onValueChange'))
              }
          }, {
              key: "handlePanResponderRequestEnd",
              value: function() {
                  return !1
              }
          }, {
              key: "handlePanResponderEnd",
              value: function(t, n) {
                  this.props.disabled || (this.setCurrentValue(this.getValue(n)), this.fireChangeEvent('onSlidingComplete'))
              }
          }, {
              key: "thumbHitTest",
              value: function(t) {
                  var n = t.nativeEvent;
                  return this.getThumbTouchRect().containsPoint(n.locationX, n.locationY)
              }
          }, {
              key: "handleStartShouldSetPanResponder",
              value: function(t) {
                  return this.thumbHitTest(t)
              }
          }, {
              key: "fireChangeEvent",
              value: function(t) {
                  this.props[t] && this.props[t](this.getCurrentValue())
              }
          }, {
              key: "getTouchOverflowSize",
              value: function() {
                  var t = this.state,
                      n = t.thumbSize,
                      u = t.allMeasured,
                      o = t.containerSize,
                      h = this.props.thumbTouchSize,
                      l = {};
                  return !0 === u && (l.width = Math.max(0, h.width - n.width), l.height = Math.max(0, h.height - o.height)), l
              }
          }, {
              key: "getTouchOverflowStyle",
              value: function() {
                  var t = this.getTouchOverflowSize(),
                      n = t.width,
                      u = t.height,
                      o = {};
                  if (void 0 !== n && void 0 !== u) {
                      var h = -u / 2;
                      o.marginTop = h, o.marginBottom = h;
                      var l = -n / 2;
                      o.marginLeft = l, o.marginRight = l
                  }
                  return !0 === this.props.debugTouchArea && (o.backgroundColor = 'orange', o.opacity = .5), o
              }
          }, {
              key: "handleMeasure",
              value: function(t, n) {
                  var u = n.nativeEvent.layout,
                      o = u.width,
                      h = u.height,
                      l = 'vertical' === this.props.orientation ? h : o,
                      s = 'vertical' === this.props.orientation ? o : h,
                      c = {
                          width: l,
                          height: s
                      },
                      p = "_" + t,
                      f = this[p];
                  f && l === f.width && s === f.height || (this[p] = c, this._containerSize && this._trackSize && this._thumbSize && this.setState({
                      containerSize: this._containerSize,
                      trackSize: this._trackSize,
                      thumbSize: this._thumbSize,
                      allMeasured: !0
                  }))
              }
          }, {
              key: "getValue",
              value: function(t) {
                  var n = this.state.containerSize.width - this.state.thumbSize.width,
                      u = (this._previousLeft + ('vertical' === this.props.orientation ? t.dy : t.dx)) / n;
                  return this.props.step ? Math.max(this.props.minimumValue, Math.min(this.props.maximumValue, this.props.minimumValue + Math.round(u * (this.props.maximumValue - this.props.minimumValue) / this.props.step) * this.props.step)) : Math.max(this.props.minimumValue, Math.min(this.props.maximumValue, u * (this.props.maximumValue - this.props.minimumValue) + this.props.minimumValue))
              }
          }, {
              key: "getCurrentValue",
              value: function() {
                  return this.state.value.__getValue()
              }
          }, {
              key: "getRatio",
              value: function(t) {
                  return (t - this.props.minimumValue) / (this.props.maximumValue - this.props.minimumValue)
              }
          }, {
              key: "getThumbLeft",
              value: function(t) {
                  return this.getRatio(t) * (this.state.containerSize.width - this.state.thumbSize.width)
              }
          }, {
              key: "getThumbTouchRect",
              value: function() {
                  var t = this.state,
                      n = t.thumbSize,
                      u = t.containerSize,
                      o = this.props.thumbTouchSize,
                      h = this.getTouchOverflowSize();
                  return 'vertical' === this.props.orientation ? new R(h.height / 2 + (u.height - o.height) / 2, h.width / 2 + this.getThumbLeft(this.getCurrentValue()) + (n.width - o.width) / 2, o.width, o.height) : new R(h.width / 2 + this.getThumbLeft(this.getCurrentValue()) + (n.width - o.width) / 2, h.height / 2 + (u.height - o.height) / 2, o.width, o.height)
              }
          }, {
              key: "renderDebugThumbTouchRect",
              value: function(t) {
                  var n = this.getThumbTouchRect(),
                      u = {
                          left: t,
                          top: n.y,
                          width: n.width,
                          height: n.height
                      };
                  return S.default.createElement(T.Animated.View, {
                      style: u,
                      pointerEvents: "none",
                      __source: {
                          fileName: k,
                          lineNumber: 319
                      }
                  })
              }
          }, {
              key: "getMinimumTrackStyles",
              value: function(t) {
                  var n = this.state,
                      u = n.thumbSize,
                      o = n.trackSize,
                      h = {
                          position: 'absolute'
                      };
                  return 'vertical' === this.props.orientation ? (h.height = T.Animated.add(t, u.height / 2), h.marginLeft = -o.width) : (h.width = T.Animated.add(t, u.width / 2), h.marginTop = -o.height), h
              }
          }, {
              key: "getThumbPositionStyles",
              value: function(t) {
                  return 'vertical' === this.props.orientation ? [{
                      translateX: -(this.state.trackSize.height + this.state.thumbSize.height) / 2
                  }, {
                      translateY: t
                  }] : [{
                      translateX: t
                  }, {
                      translateY: -(this.state.trackSize.height + this.state.thumbSize.height) / 2
                  }]
              }
          }, {
              key: "render",
              value: function() {
                  var t = this.props,
                      n = t.minimumValue,
                      o = t.maximumValue,
                      s = t.minimumTrackTintColor,
                      c = t.maximumTrackTintColor,
                      p = t.thumbTintColor,
                      f = t.containerStyle,
                      b = t.style,
                      v = t.trackStyle,
                      y = t.thumbStyle,
                      w = t.debugTouchArea,
                      V = t.orientation,
                      C = (0, h.default)(t, ["minimumValue", "maximumValue", "minimumTrackTintColor", "maximumTrackTintColor", "thumbTintColor", "containerStyle", "style", "trackStyle", "thumbStyle", "debugTouchArea", "orientation"]),
                      P = this.state,
                      R = P.value,
                      _ = P.containerSize,
                      M = P.thumbSize,
                      O = P.allMeasured,
                      E = f || x,
                      A = R.interpolate({
                          inputRange: [n, o],
                          outputRange: [0, _.width - M.width]
                      }),
                      j = {};
                  O || (j.height = 0, j.width = 0);
                  var N = z({}, this.getMinimumTrackStyles(A), {
                          backgroundColor: s
                      }, j),
                      L = y && y.transform || [],
                      D = this.getTouchOverflowStyle();
                  return S.default.createElement(T.View, (0, l.default)({}, C, {
                      style: T.StyleSheet.flatten(['vertical' === V ? E.containerVertical : E.containerHorizontal, b]),
                      onLayout: this.measureContainer,
                      __source: {
                          fileName: k,
                          lineNumber: 397
                      }
                  }), S.default.createElement(T.View, {
                      style: T.StyleSheet.flatten([E.track, 'vertical' === V ? E.trackVertical : E.trackHorizontal, v, {
                          backgroundColor: c
                      }]),
                      onLayout: this.measureTrack,
                      __source: {
                          fileName: k,
                          lineNumber: 407
                      }
                  }), S.default.createElement(T.Animated.View, {
                      style: T.StyleSheet.flatten([E.track, 'vertical' === V ? E.trackVertical : E.trackHorizontal, v, N]),
                      __source: {
                          fileName: k,
                          lineNumber: 418
                      }
                  }), S.default.createElement(T.Animated.View, {
                      testID: "sliderThumb",
                      onLayout: this.measureThumb,
                      style: T.StyleSheet.flatten([{
                          backgroundColor: p
                      }, E.thumb, 'vertical' === V ? E.thumbVertical(v && v.width) : E.thumbHorizontal(v && v.height), y, z({
                          transform: [].concat((0, u.default)(this.getThumbPositionStyles(A)), (0, u.default)(L))
                      }, j)]),
                      __source: {
                          fileName: k,
                          lineNumber: 428
                      }
                  }), S.default.createElement(T.View, (0, l.default)({
                      style: T.StyleSheet.flatten([x.touchArea, D])
                  }, this.panResponder.panHandlers, {
                      __source: {
                          fileName: k,
                          lineNumber: 447
                      }
                  }), !0 === w && this.renderDebugThumbTouchRect(A)))
              }
          }]), n
      })(S.Component);
  e.Slider = _, _.propTypes = {
      value: y.default.number,
      disabled: y.default.bool,
      minimumValue: y.default.number,
      maximumValue: y.default.number,
      step: y.default.number,
      minimumTrackTintColor: y.default.string,
      maximumTrackTintColor: y.default.string,
      thumbTintColor: y.default.string,
      thumbTouchSize: y.default.shape({
          width: y.default.number,
          height: y.default.number
      }),
      onValueChange: y.default.func,
      onSlidingStart: y.default.func,
      onSlidingComplete: y.default.func,
      style: w.ViewPropTypes.style,
      trackStyle: w.ViewPropTypes.style,
      thumbStyle: w.ViewPropTypes.style,
      debugTouchArea: y.default.bool,
      animateTransitions: y.default.bool,
      animationType: y.default.oneOf(['spring', 'timing']),
      orientation: y.default.oneOf(['horizontal', 'vertical']),
      animationConfig: y.default.object,
      containerStyle: w.ViewPropTypes.style
  }, _.defaultProps = {
      value: 0,
      minimumValue: 0,
      maximumValue: 1,
      step: 0,
      minimumTrackTintColor: '#3f3f3f',
      maximumTrackTintColor: '#b3b3b3',
      thumbTintColor: 'red',
      thumbTouchSize: {
          width: 40,
          height: 40
      },
      debugTouchArea: !1,
      animationType: 'timing',
      orientation: 'horizontal'
  };
  var x = T.StyleSheet.create({
          containerHorizontal: {
              height: 40,
              justifyContent: 'center'
          },
          containerVertical: {
              width: 40,
              flexDirection: 'column',
              alignItems: 'center'
          },
          track: {
              borderRadius: 2
          },
          trackHorizontal: {
              height: 4
          },
          trackVertical: {
              flex: 1,
              width: 4
          },
          thumb: {
              position: 'absolute',
              width: 20,
              height: 20,
              borderRadius: 10
          },
          thumbHorizontal: function(t) {
              return {
                  top: 22 + (t ? (t - 4) / 2 : 0)
              }
          },
          thumbVertical: function(t) {
              return {
                  left: 22 + (t ? (t - 4) / 2 : 0)
              }
          },
          touchArea: {
              position: 'absolute',
              backgroundColor: 'transparent',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0
          },
          debugThumbTouchArea: {
              position: 'absolute',
              backgroundColor: 'green',
              opacity: .5
          }
      }),
      M = (0, w.withTheme)(_, 'Slider');
  e.default = M
}